<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>被Windows更新狂暴鸿儒的Arch Linux</title>
    <link href="/blog/2023/11/05/update-windows-break-archlinux/"/>
    <url>/blog/2023/11/05/update-windows-break-archlinux/</url>
    
    <content type="html"><![CDATA[<p>在Windows更新之后发现Linux无法启动之后面露难色的<del>两人</del>一人。</p><span id="more"></span><h2 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h2><p>某日Windows进行了一次更新，本以为无事发生，结果第二天试图启动Linux时发现：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">Initramfs unpacking failed: invalid magic <span class="hljs-built_in">at</span> <span class="hljs-built_in">start</span> of compressed archive<br></code></pre></td></tr></table></figure><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>首先判断是Windows更新橄榄了Linux启动使用的<code>initramfs</code>导致的，关于这个东西的介绍详解<a href="https://wiki.archlinux.org/title/Arch_boot_process#initramfs">Arch boot process</a>。</p><p>于是尝试使用<code>Arch ISO</code>启动系统重新生成<code>initramfs</code>解决。</p><p>在<code>arch-chroot</code>之后使用<code>mkinitramfs -P</code>试图重新生成<code>initramfs</code>，但是在重启之后仍然出现类似的提示。遂求助伟大的搜索引擎。</p><p>发现搜索引擎给出了相同的解决方案，，，这时我已经开始慌乱了。再次进入<code>Arch ISO</code>打包<code>home</code>目录为重装做准备。</p><p>有帖子分析说Windows更新可以会把<code>/boot</code>的分区格式给橄榄，可以尝试使用<code>fsck</code>进行修复。</p><p>进入<code>Arch ISO</code>，使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fsck -r /dev/nvmen0p1<br></code></pre></td></tr></table></figure><p>对分区进行修复，没想到还扫描出现错误：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">There are <span class="hljs-keyword">differences </span><span class="hljs-keyword">between </span><span class="hljs-keyword">boot </span>sector <span class="hljs-keyword">and </span>its <span class="hljs-keyword">backup.</span><br><span class="hljs-keyword"></span>This is mostly harmless.<br></code></pre></td></tr></table></figure><p>（具体提示的错误bit我给忘记了）</p><p>我选择使用<code>Copy backup to original</code>来修复这个错误。还出现了一个</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-literal">two</span> <span class="hljs-keyword">or</span> more <span class="hljs-built_in">files</span> share <span class="hljs-keyword">the</span> same cluseters<br></code></pre></td></tr></table></figure><p>的错误，冲突的文件是<code>amd-ucode.img</code>和<code>bootmgfw.efi.mui</code>文件，我也选择了修复。</p><p>我又在网上翻到一篇帖子说可以试试<code>pacman</code>更新系统和重新安装<code>linux</code>包，再想到这两天一直在<code>Windows</code>下写文档，确实可以试试，于是就：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Syu<br>pacman -Sy linux<br></code></pre></td></tr></table></figure><p>回来吧，我的Linux，，，</p><h2 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h2><p>因为在第二次进入<code>Arch ISO</code>中我同时使用了<code>fsck</code>和<code>pacman</code>两个工具同时进行修复，因此我无法判断具体是哪个工具修复了这个问题，不过鉴于这次更新也没有安装新的内核版本，而且我之间也已经手动执行过<code>mkinitramfs -P</code>。</p><p>在加上在互联网上已经有大量关于Windows更新可能会破坏启动分区，尤其是这次的Windows更新还是一个较大的版本更新，因此我认为就是Windows干的好事，微软你不得house，，，</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决云原神无法在Linux中浏览器下运行的问题</title>
    <link href="/blog/2023/10/09/linux-genshin-cloud/"/>
    <url>/blog/2023/10/09/linux-genshin-cloud/</url>
    
    <content type="html"><![CDATA[<h1 id="解决云原神无法在Linux中浏览器下运行的问题"><a href="#解决云原神无法在Linux中浏览器下运行的问题" class="headerlink" title="解决云原神无法在Linux中浏览器下运行的问题"></a>解决云原神无法在Linux中浏览器下运行的问题</h1><p>本文为转载<code>bilibili</code>用户<a href="https://space.bilibili.com/33027704">@SocialismTeen</a>在他的<a href="https://www.bilibili.com/read/cv26576757">专栏</a>中给出的解决办法。</p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在<code>Linux</code>平台上使用<code>Chromium</code>系列内核的浏览器打开<a href="https://ys.mihoyo.com/cloud/#/">云原神</a>会发生鼠标无法控制视角的问题。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>根据上面提到那位同志的研究，该问题是由于云原神在获得鼠标移动时使用的<code>API</code>: <code>Pointer Lock API</code>。在<strong>其他</strong>平台上该<code>API</code>支持名为<code>unadjustedMovement</code>的参数以关闭鼠标加速获得更好的体验，但是在<code>Linux</code>平台上并不支持该参数，因此程序无法正确获得到鼠标指针的位置。</p><p>该同志给出的解决办法为使用钩子函数消除调用该<code>API</code>时的参数，使用的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> origin = HTMLElement.prototype.requestPointerLock<br>HTMLElement.prototype.requestPointerLock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> origin.call(<span class="hljs-built_in">this</span>)<br>&#125; <br></code></pre></td></tr></table></figure><p>为了获得良好的游戏体验，可以使用<a href="https://www.tampermonkey.net/">油猴插件</a>在进入网页时自动运行上述脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ==UserScript==</span><br><span class="hljs-comment">// @name         Genshin Cloud</span><br><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><br><span class="hljs-comment">// @version      0.1</span><br><span class="hljs-comment">// @description  fix a Genshin Impact cloud game bug</span><br><span class="hljs-comment">// @match        https://ys.mihoyo.com/cloud/*</span><br><span class="hljs-comment">// @grant        none</span><br><span class="hljs-comment">// ==/UserScript==</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br><br>  <span class="hljs-keyword">const</span> origin = HTMLElement.prototype.requestPointerLock<br>  HTMLElement.prototype.requestPointerLock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> origin.call(<span class="hljs-built_in">this</span>)<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>原神</tag>
      
      <tag>生活小妙招</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日用Linux挑战 第三篇</title>
    <link href="/blog/2023/09/04/daily-linux-3/"/>
    <url>/blog/2023/09/04/daily-linux-3/</url>
    
    <content type="html"><![CDATA[<h1 id="日用Linux挑战-第三篇"><a href="#日用Linux挑战-第三篇" class="headerlink" title="日用Linux挑战 第三篇"></a>日用Linux挑战 第三篇</h1><p>成也开源，败也开源。</p><span id="more"></span><h2 id="放弃-Wayland"><a href="#放弃-Wayland" class="headerlink" title="放弃 Wayland"></a>放弃 <code>Wayland</code></h2><h3 id="转向labwc"><a href="#转向labwc" class="headerlink" title="转向labwc"></a>转向<code>labwc</code></h3><p>在使用<code>Hyprland</code>这个平铺式窗口管理器大概三个月之后，我开始怀疑自己是否真的需要一个平铺式的窗口管理器。</p><p>作为一个主打“平铺”式管理的桌面管理器，我却很少同时在一块屏幕上显示多个应用，都是将应用全屏之后在显示，再搭配<code>Meta+1\2\3</code>切换不同的<code>workspace</code>实现不同应用切换的功能。这让我开始思考，也许，我根本不适合使用一个“平铺式”的窗口管理器。其次，我常用的<code>IDE</code>——<code>IDEA</code>系列让我遇到了一个极为恶性的<code>bug</code>：代码重构的弹出式窗口需要很长的一段时间才能显示出来，其时间甚至足够我去喝口水上个厕所。如果我在上班，那么我肯定不会放弃这个显而易见的摸鱼机会，可惜不是。这个<code>bug</code>虽然不致命但是过于恶心，毕竟很好的重构思路被打断真的很想先把鼠标扔出去再把电脑砸了。</p><p>然后我就开始研究工作在<code>wayland</code>显示协议之下的堆叠式窗口管理器。首先，我惊喜的发现，目前<code>Linux</code>下的两大主流的桌面环境都开始默认使用<code>wayland</code>显示协议，<del>虽然我并不打算将这两个臃肿的家伙请回来</del>。打开我们伟大的<code>Arch Linux Wiki</code>，打开<code>wayland</code>页面，这里已经贴心的为我们整理好了使用<code>wayland</code>显示协议的堆叠式窗口管理器：</p><ul><li><code>enlightenment</code>：进入官网一看，对于<code>wayland</code>的支持还是“实验性”阶段，pass</li><li><code>hikari</code>：针对<code>FreeBSD</code>开发，pass</li><li><code>KWin</code>：<code>KDE</code>使用的窗口管理器，pass</li><li><code>Liri Shell</code>：不知为何被我华丽无视，pass</li><li><code>labwc</code>：看上去还行，一会试试</li><li><code>mutter</code>：<code>gnome</code>使用的窗口管理器，pass</li><li><code>wayfire</code>：<code>aur</code>里面的官方包都不能过编译，这种粪软件还是算了吧</li><li><code>weston</code>：<code>wayland</code>示例合成器总给人一种怪怪的感觉，pass</li><li><code>wio</code>：官网连接被标记为<code>dead-link</code>，pass</li></ul><p>首先尝试<code>labwc</code>，虽然这个软件在<code>Github</code>上只有800多颗星，不过作为一个小而精的窗口管理器，这个哥们还是比较完美的适配了我的需求，虽然遇到诸多的小问题：</p><ul><li>没有提供在启动窗口管理器时设置环境变量的方法，导致只能修改<code>desktop</code>文件实现这个功能。</li><li>设置触控板的自然滚动失败</li></ul><p>而且作为基于<code>wlroots</code>合成器开发的窗口管理器，可以完美继承我在<code>Hyprland</code>下的不少设置，像<code>waybar</code>、<code>hyprpaper</code>等等。</p><h3 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h3><p>从今年五月份被<code>Hyprland</code>种草，切换到<code>Wayland</code>显示协议时算起，我已经使用了三个月的<code>Wayland</code>显示协议。刚刚切换到<code>labwc</code>使用没超过一周，我就遇到了在<code>wayland</code>下的最大缺陷：<code>matlab</code>没法正常的使用——虽然软件主界面还可以正常的打开，但是所有的子窗口都没办法打开。恰好那两天我必须要用<code>matlab</code>完成一个作业，我直接一波<code>sudo pacman -S plasma</code>润回了<code>KDE</code>。</p><p>虽然这个故事听着可能有点突然，但确实就这么发生了，写作这篇博客时使用的桌面环境已经是<code>KDE</code>了。</p><p>下面就简单讲讲这次使用<code>KDE</code>的美化思路。这次使用<code>KDE</code>几乎完全继承了之前的<a href="https://rrricardo.top/blog/2023/01/15/daily-linux-0/">美化思路</a>，其中主要的变化为：</p><ul><li>使用<code>kitty</code>作为终端模拟器</li><li>使用类似于<code>Windows</code>下的任务栏显示模式，而不是只显示图标</li><li>继承了部分在<code>Hyprland</code>下的快捷键<ul><li><code>Meta+F</code>全屏应用</li><li><code>Meta+W</code>关闭应用</li></ul></li></ul><p><img src="/blog/2023/09/04/daily-linux-3/Screenshot_20230904_144149.png"></p><h3 id="Fuck-You-NVIDIA"><a href="#Fuck-You-NVIDIA" class="headerlink" title="Fuck You NVIDIA"></a>Fuck You NVIDIA</h3><p><code>matlab</code>还不是给予最后一击的东西。当我搞到一台使用NVIDIA显卡的笔记本时，真正的噩梦才刚刚开始。首先是驱动，作为一个被<code>FUCK</code>的公司，NIVDIA现在在<code>Linux</code>上具有三个不同的驱动程序：<code>nouveau</code>开源实现的驱动程序，<code>nvidia</code>NVIDIA提供的私有驱动程序，<code>nvidia-open</code>NVIDIA提供的开源驱动程序，其中<code>nvidia-open</code>还在积极的开发阶段，显然是被<code>FUCK</code>太多推出的产物。</p><p>参考<code>Hyprland</code>官方文档中对于NVIDIA的支持页面，需要安装<code>nvidia-open-dkms</code>包再加上几个内核参数。咔咔咔一顿操作之后，期待的等待电脑重启。<code>Linux</code>万年不变的启动信息刷过，然后电脑就黑屏了。</p><p>作为一个经验丰富的NVIDIA受害者，我轻轻一搜就发现这个由于INTEL的内核驱动和NVIDIA内核驱动冲突导致的问题。然而现在不能进系统，我不得不紧急学习了一波内核启动参数，通过在<code>grub</code>中修改启动参数禁用<code>intel_i915</code>模块才将系统启动了起来。</p><p>装好了驱动，现在开始装桌面环境。很遗憾，默认版本的<code>wlroots</code>在NVIDIA驱动下兼容性不佳，需要自行修改源代码自行编译，虽然有着万能的<code>AUR</code>辅助我们，但是好巧不巧，那段时间正好遇到<code>Hyprland</code>项目调整文件结构，使用<code>AUR</code>编译失败了。于是我不得不手动<code>clone</code>下来修改之后手动编译。</p><p>历尽千难万险，终于进入了<code>Hyprland</code> 的桌面。   本来以为安装完成之后就可以愉快的享（gong）受（zuo）了，没想到是折磨的开始。</p><p>首先是屏幕闪烁的问题，能明显感觉到屏幕会闪烁，出现的时机是完全随机的。按照<code>wiki</code>上的说明，在源代码上打上<code>patch</code>之后重新编译安装，没用。文档上还记录了一种“核武器”方式，但是需要修改内核配置和造成功耗提升，不敢试。然后是在<code>vscode</code>中遇到“屏幕冻结”的问题。这个问题在频繁上下滚动的时候特别容易出现，具体表现为滚动了但是屏幕上的一部分还是显示滚动之前的内容没有刷新。</p><p>上述问题正好发生在我发现<code>matlab</code>没法在<code>wayland</code>下正常工作的时候，一怒之下我就回到了<code>KDE</code>。</p><p>已经是2023年了，<code>Wayland</code>仍然是<code>Linux</code>桌面环境永远的痛。</p><h2 id="双系统的奇妙bug"><a href="#双系统的奇妙bug" class="headerlink" title="双系统的奇妙bug"></a>双系统的奇妙bug</h2><p>上文中提到我搞到了一台使用NVIDIA显卡的笔记本，拥有了<strong>强劲</strong>图形性能怎么能不玩游戏呢。但是<code>Linux</code>对于游戏支持程序实在是一言难尽，具体可以查看这个系列前几篇我和原神的相爱相杀。于是我就选择了安装<code>Windows</code>和<code>Linux</code>双系统。</p><p>由于这台笔记本支持安装多个<code>m.2</code>的硬盘位，因此我就将两个系统安装到了两个不同的硬盘中，使用<code>grub</code>切换在启动时需要进入哪个系统。</p><h3 id="iwlwifi加载失败的问题"><a href="#iwlwifi加载失败的问题" class="headerlink" title="iwlwifi加载失败的问题"></a><code>iwlwifi</code>加载失败的问题</h3><p>虽然安装的过程一帆风顺，但是使用的过程却是波折连连。出现的第一个问题就是<code>iwlwifi</code>这个驱动程序在从<code>Windows</code>切换到<code>Linux</code>的启动过程中会启动失败。使用<code>dmesg</code>可以观察到如下的报错：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">iwlwifi:</span> probe <span class="hljs-keyword">of</span> xxxx:xx:xx:x failed <span class="hljs-keyword">with</span> <span class="hljs-keyword">error</span> -<span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>一通咕狗容易发现这样的一个<a href="https://bugzilla.kernel.org/show_bug.cgi?id=209641#c55">bug</a>，似乎是由于<code>Windows</code>使用快速启动造成的。</p><p>解决办法或者说“回避策略”有两个：</p><ul><li>关闭<code>Windows</code>的快速启动</li><li>遇到这个问题了重启<code>Linux</code></li></ul><p>于是干掉快速启动。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自定义注解实现权限控制</title>
    <link href="/blog/2023/07/29/spring-boot-custom-authorize/"/>
    <url>/blog/2023/07/29/spring-boot-custom-authorize/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot自定义注解实现权限控制"><a href="#SpringBoot自定义注解实现权限控制" class="headerlink" title="SpringBoot自定义注解实现权限控制"></a>SpringBoot自定义注解实现权限控制</h1><span id="more"></span><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>最近在用<code>SpringBoot</code>写一个数据结构的大作业，实现一个日程管理系统。在系统需要有不同用户的权限管理功能。但是<code>SpringBoot</code>框架中使用的<code>Spring Security</code>权限控制框架有点过于“重”了，对于我们这种小项目来说不太适用。</p><p>于是我们打算利用<code>Spring</code>中比较强大的注解功能自行设计实现一套权限控制功能。这个功能需要实现一下这些功能：</p><ul><li>基于<code>Json Web Token</code>的登录状态维持。</li><li>不同的用户具有不同的权限</li><li>使用注解注明每个接口设置的权限类型</li><li>在控制器中可以获得当前请求用户的身份信息</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="权限等级和策略等级"><a href="#权限等级和策略等级" class="headerlink" title="权限等级和策略等级"></a>权限等级和策略等级</h3><p>首先明确一下我们需要支持的权限等级，通过枚举的方式表现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UserPermission</span> </span>&#123;<br>    USER(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;user&quot;</span>),<br>    ADMIN(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;administrator&quot;</span>),<br>    SUPER(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;superman&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    UserPermission(<span class="hljs-keyword">int</span> code, String name) &#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里我们使用了经典的三层等级制度。</p><p>然后明确一下我们对于各个接口的权限要求，这里也采用枚举的方式给出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AuthorizePolicy</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 只要登录就可以访问</span><br><span class="hljs-comment">     */</span><br>    ONLY_LOGIN(<span class="hljs-string">&quot;onlyLogin&quot;</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户在当前请求的组织中</span><br><span class="hljs-comment">     */</span><br>    CURRENT_GROUP_USER(<span class="hljs-string">&quot;currentGroupUser&quot;</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户在当前请求的组织中 且权限在管理员之上</span><br><span class="hljs-comment">     */</span><br>    CURRENT_GROUP_ADMINISTRATOR(<span class="hljs-string">&quot;currentGroupAdministrator&quot;</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户在当前请求的组织中 且权限在超级管理员之上</span><br><span class="hljs-comment">     */</span><br>    CURRENT_GROUP_SUPERMAN(<span class="hljs-string">&quot;currentGroupSuperman&quot;</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前用户可以访问（URL终结点包含用户ID）</span><br><span class="hljs-comment">     */</span><br>    CURRENT_USER(<span class="hljs-string">&quot;currentUser&quot;</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户权限超过普通管理员</span><br><span class="hljs-comment">     */</span><br>    ABOVE_ADMINISTRATOR(<span class="hljs-string">&quot;aboveAdministrator&quot;</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户权限超过超级管理员</span><br><span class="hljs-comment">     */</span><br>    ABOVE_SUPERMAN(<span class="hljs-string">&quot;aboveSuperman&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String implementName;<br><br>    AuthorizePolicy(String implementName) &#123;<br>        <span class="hljs-keyword">this</span>.implementName = implementName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getImplementName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.implementName;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里<code>current</code>开头相关策略有点粪的一点是，为了确保每个用户只能访问自己相关的数据，我们会从请求<code>url</code>中读取当前请求对象的ID。因为我们采用了<code>RESTful API</code>的设计思想，因此形如<code>/user/1</code>之类的请求就表示对于ID等于1的用户进行请求。但是这样设计就存在两个问题：</p><ul><li>从编程的角度出发，<code>current</code>相关策略就只能使用在<code>url</code>最后为对象ID的接口上，但是这是一个<strong>口头约定</strong>，实际代码中没有任何限制，因此当错误使用这类策略时就会引起不必要的运行时错误。</li><li>从应用的角度出发，从<code>url</code>中获得数据也显得有一点奇怪。</li></ul><h3 id="策略实现服务"><a href="#策略实现服务" class="headerlink" title="策略实现服务"></a>策略实现服务</h3><p>为了实现不同策略服务，我们设计了一个认证接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.rrricardo.postcalendarbackend.services;<br><br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.dtos.UserDTO;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.exceptions.NoIdInPathException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorizeService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证用户的权限</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户DTO模型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestUri 请求的URI</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否通过拥有权限</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">authorize</span><span class="hljs-params">(UserDTO user, String requestUri)</span> <span class="hljs-keyword">throws</span> NoIdInPathException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中输入的两个参数分别是在令牌中解析出来的用户信息（通过<code>json</code>的形式存储在<code>JWT</code>令牌中）和当前请求的<code>url</code>。</p><p>然后针对每个策略实现一个认证服务：</p><p><img src="/blog/spring-boot-custom-authorize/image-20230727175807814.png" alt="image-20230727175807814"></p><blockquote><p>具体实现就不在这里给出。</p></blockquote><p>在注入每个服务时，使用策略枚举作为服务的名称，方便后续获得该服务实例。</p><p><img src="/blog/spring-boot-custom-authorize/image-20230727175955817.png" alt="image-20230727175955817"></p><h3 id="注解和注解解析"><a href="#注解和注解解析" class="headerlink" title="注解和注解解析"></a>注解和注解解析</h3><p>首先实现一个<strong>运行时</strong>，<strong>注解在方法上</strong>的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Authorize &#123;<br>    <span class="hljs-function">AuthorizePolicy <span class="hljs-title">policy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> AuthorizePolicy.ONLY_LOGIN</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后实现一个注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.rrricardo.postcalendarbackend.components;<br><br><span class="hljs-keyword">import</span> io.jsonwebtoken.JwtException;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.method.HandlerMethod;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.annotations.Authorize;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.dtos.ResponseDTO;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.dtos.UserDTO;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.exceptions.NoIdInPathException;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.services.JwtService;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtService jwtService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthorizeServiceFactory authorizeServiceFactory;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDTO&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthorizeInterceptor</span><span class="hljs-params">(JwtService jwtService, AuthorizeServiceFactory authorizeServiceFactory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.jwtService = jwtService;<br>        <span class="hljs-keyword">this</span>.authorizeServiceFactory = authorizeServiceFactory;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod handlerMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> method = handlerMethod.getMethod();<br>        <span class="hljs-keyword">var</span> authorize = method.getAnnotation(Authorize.class);<br>        <span class="hljs-keyword">if</span> (authorize == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 没有使用注解</span><br>            <span class="hljs-comment">// 说明不需要身份验证</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 验证是否携带令牌</span><br>        <span class="hljs-keyword">var</span> tokenHeader = request.getHeader(jwtService.header);<br>        <span class="hljs-keyword">if</span> (tokenHeader == <span class="hljs-keyword">null</span> || !tokenHeader.startsWith(jwtService.tokenPrefix)) &#123;<br>            <span class="hljs-keyword">var</span> responseDTO = <span class="hljs-keyword">new</span> ResponseDTO&lt;UserDTO&gt;(<span class="hljs-string">&quot;No token provided.&quot;</span>);<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            response.getWriter().println(responseDTO);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">var</span> claims = jwtService.parseJwtToken(tokenHeader);<br>            <span class="hljs-keyword">var</span> userDTO = <span class="hljs-keyword">new</span> UserDTO(<br>                    claims.get(<span class="hljs-string">&quot;userId&quot;</span>, Integer.class),<br>                    claims.getIssuer(),<br>                    claims.get(<span class="hljs-string">&quot;emailAddress&quot;</span>, String.class)<br>            );<br>            <span class="hljs-keyword">var</span> authService = authorizeServiceFactory.getAuthorizeService(authorize.policy());<br><br>            <span class="hljs-keyword">if</span> (authService.authorize(userDTO, request.getRequestURI())) &#123;<br>                local.set(userDTO);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">var</span> responseDTO = <span class="hljs-keyword">new</span> ResponseDTO&lt;UserDTO&gt;(<span class="hljs-string">&quot;No permission&quot;</span>);<br><br>                response.setStatus(<span class="hljs-number">403</span>);<br>                response.getWriter().println(responseDTO);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (JwtException e) &#123;<br>            <span class="hljs-comment">// 解析令牌失败</span><br>            <span class="hljs-keyword">var</span> responseDTO = <span class="hljs-keyword">new</span> ResponseDTO&lt;UserDTO&gt;(e.getMessage());<br><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            response.getWriter().println(responseDTO);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (NoIdInPathException e) &#123;<br>            <span class="hljs-comment">// 在请求路径中没有获取到用户ID</span><br>            <span class="hljs-keyword">var</span> responseDTO = <span class="hljs-keyword">new</span> ResponseDTO&lt;UserDTO&gt;(<span class="hljs-string">&quot;Internal server error, please contact administrator&quot;</span>);<br><br>            response.setStatus(<span class="hljs-number">500</span>);<br>            response.getWriter().println(responseDTO);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;<br>        local.remove();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDTO <span class="hljs-title">getUserDTO</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> local.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中重要的部分是声明了一个<code>ThreadLocal</code>的变量，当前的处理线程可以通过这个变量获得当前发起请求的用户信息。</p><p>在上述实现中还涉及到使用<code>AuthorizeServiceFactory</code>的部分，这是因为在配置注解处理器时不能使用依赖注入，需要手动创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.components.AuthorizeInterceptor;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.components.AuthorizeServiceFactory;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.services.JwtService;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtService jwtService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthorizeServiceFactory authorizeServiceFactory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebMvcConfiguration</span><span class="hljs-params">(JwtService jwtService, AuthorizeServiceFactory authorizeServiceFactory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.jwtService = jwtService;<br>        <span class="hljs-keyword">this</span>.authorizeServiceFactory = authorizeServiceFactory;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> AuthorizeInterceptor(jwtService, authorizeServiceFactory));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们就实现了一个<code>AuthorizeServiceFactory</code>，在解决依赖注入问题的同时封装了一部分的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.enums.AuthorizePolicy;<br><span class="hljs-keyword">import</span> top.rrricardo.postcalendarbackend.services.AuthorizeService;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizeServiceFactory</span> </span>&#123;<br>    Map&lt;String, AuthorizeService&gt; authorizeServiceMap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthorizeServiceFactory</span><span class="hljs-params">(Map&lt;String, AuthorizeService&gt; authorizeServiceMap)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.authorizeServiceMap = authorizeServiceMap;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthorizeService <span class="hljs-title">getAuthorizeService</span><span class="hljs-params">(AuthorizePolicy policy)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> authorizeServiceMap.get(policy.getImplementName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实际引用"><a href="#实际引用" class="headerlink" title="实际引用"></a>实际引用</h2><p>我们在项目<a href="https://github.com/post-guard/PostCalendarBackend">PostCalendarBackend</a>中实际使用的这个技术，相关代码在可以在Github上获取。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日用Linux挑战 第2篇</title>
    <link href="/blog/2023/07/23/daily-linux-2/"/>
    <url>/blog/2023/07/23/daily-linux-2/</url>
    
    <content type="html"><![CDATA[<h1 id="日用Linux挑战-第2篇"><a href="#日用Linux挑战-第2篇" class="headerlink" title="日用Linux挑战 第2篇"></a>日用Linux挑战 第2篇</h1><p>使用<code>Linux</code>6个月，我成功戒掉了原神。</p><span id="more"></span><h2 id="使用Wayland开启桌面环境"><a href="#使用Wayland开启桌面环境" class="headerlink" title="使用Wayland开启桌面环境"></a>使用Wayland开启桌面环境</h2><p>在上一篇<a href="https://rrricardo.top/blog/2023/03/08/daily-linux-1/">文章</a>我尝试在<code>kde</code>桌面环境下使用<code>wayland</code>显示协议，当时的尝试虽然失败了，却为我这次迁移到<code>wayland</code>打下了良好的基础，例如我将输入法从迁移到<code>fcitx5</code>。</p><p>最近恰好被平铺式的窗口管理器种草，又在B站上看见一个动画绚丽的<code>wayland</code>合成器——<a href="https://hyprland.org/">Hyprland</a>，当即脑袋一热，就把<code>kde</code>干掉，装上了<code>hyprland</code>。</p><p><img src="/blog/2023/07/23/daily-linux-2/df4211f6be2724b3b4725f7ce5a4078818844857.jpg" alt="img"></p><p>安装<code>hyprland</code>的过程非常舒适，<code>hyprland</code>被打包为一个单独的二进制文件，使用<code>pacman</code>安装之后直接在<code>tty</code>下执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hyprland<br></code></pre></td></tr></table></figure><p>就可以打开一个干净到极致的桌面环境——没有图标，状态栏等等传统桌面应该有的一切，只有一张简单的壁纸。然后我就发现我完全不会使用这个桌面，虽然鼠标还是如预期一般出现了，但是没有任何用处，<code>hyprland</code>的一切都需要使用键盘启动。在对着<code>hyprland</code>8个大字发愣5秒钟之后，我便屁滚尿流的滚回了<code>tty</code>。虽然文档中说明了在默认的配置文件中使用<code>win+q</code>的组合键打开终端，但是默认的终端应用程序是<code>kitty</code>，然而这个冷门的终端程序在我的电脑上自然是没有的（虽然我在使用过后觉得这个中断程序秒杀我之前用过的全部终端）。看到简陋但是熟悉的<code>tty</code>仿佛见到了亲人，我一波<code>sudo pacman -S kitty</code>，一边看着进度条飞涨一边感谢<code>archlinux</code>。迅速按下<code>ctrl+shift+F1</code>，回到忠诚的壁纸画面，不过这次，轻轻按下<code>win+q</code>，一个终端窗口如宿命一般出现！</p><blockquote><p>上面因为作者刚考完期末神智有点不正常，还请<del>根本不存在的</del>读者海涵。</p></blockquote><p>在<code>Linux</code>下拥有了终端就好办了。首先装上<code>App Launcher</code>——没有这玩意儿我似乎就只能从终端里启动应用程序，显然是十二分的不方便。在一番比较之后，我在官方文档中选择了<code>fuzzel</code>，看上去挺好看的。</p><blockquote><p>本来这里想截一张<code>fuzzel</code>的图，但是似乎他们的主页挂掉了（</p></blockquote><p>安装了<code>App Launcher</code>之后，至少可以打开浏览器，愉快的复制粘贴安装了。剩下的安装过程就按下不表，基本上按照官方文档的<code>Useful Utilities</code>进行，在中间选择自己需要的软件的进行安装。然后便是根据配置文件的说明对于外观和使用快捷键进行调整，以及配置壁纸软件<code>hyprpaper</code>和状态栏组件<code>waybar</code>。具体的配置文件我都放在了自建的<code>git</code>服务器上，可以在<a href="https://git.rrricardo.top/jackfiled/dot-config">这里</a>查看。</p><h3 id="Wayland软件兼容性"><a href="#Wayland软件兼容性" class="headerlink" title="Wayland软件兼容性"></a>Wayland软件兼容性</h3><p>跳槽到了新的<code>wayland</code>显示协议，最关心的自然是各种软件是否能在<code>wayland</code>下正常的工作。</p><p>首先是各种浏览器。在我安装的这段时间里（2023年5月），<code>microsoft edge</code>浏览器是基本不能在<code>wayland</code>模式下工作，一进入全屏模式就会自动崩溃退出，这对于日常电脑刷视频的我来说简直不能忍受。幸好，<code>firefox</code>浏览器在<code>wayland</code>模式下工作正常，不愧是和<code>Linux</code>关系最好的浏览器。再通过一系列的测试，<code>chromium</code>系列的浏览器在<code>wayland</code>下的工作状态都不太好，如果需要在<code>wayland</code>环境下使用<code>chromium</code>系列的浏览器，建议还是运行在<code>xwayland</code>模式下。</p><p>然后是各种开发工具。我日常使用的<code>jetbrains</code>IDE和<code>VSCode</code>都工作正常，虽然是工作在<code>xwayland</code>模式下。</p><p>各种在学习过程中遇到的工具软件：基本上都工作运行良好。当然因为没有设置缩放的问题而导致字体都很小。因为如果在配置文件中设置缩放之后会导致字体发虚。下面的截图就是我将我的2K显示屏设置为150%缩放的效果，<del>虽然在截图中的效果不明显</del>。目前在常用软件中唯一让我十分不满意的软件是<code>wps</code>，使用体验完全无法和<code>offices</code>相提并论，目前我正在研究使用<code>wine</code>运行<code>offices</code>，如果成功了就再水一篇博客庆祝一下。</p><p><img src="/blog/2023/07/23/daily-linux-2/image-20230702205919301.png" alt="image-20230702205919301"></p><blockquote><p>最新的进展是使用<code>wine</code>没法安装学校提供的<code>office 2021</code>，同时我又不愿意使用古老的<code>office</code>版本，但是我发现一个称作<code>onlyoffice</code>的第三方软件蛮好用的，等我试用一段时间再说。</p><p>但是<code>onlyoffice</code>的最新版本和<code>wlroots</code>合成器似乎有点八字不合，我现在是回退到<code>7.2.1</code>版本正常使用，详情见这个<a href="https://github.com/ONLYOFFICE/DesktopEditors/issues/1208">issue</a></p></blockquote><p>最后就是各种游戏的兼容性了。原神完蛋了。虽然这和<code>wayland</code>关系并不是很大，米哈游自己也罪大恶极，但是我换成<code>wayland</code>之后的游戏流畅度下降明显，只能眨眼补帧，在硬顶了几周之后我绷不住退游了。目前还不知道是由于原神本身一坨大便的优化还是<code>wayland</code>导致的性能下降。而我在<code>steam</code>上的各种游戏工作也不是很正常，尤其是各种需要全屏的游戏，比如<code>CS:GO</code>，可能是由于我使用外接屏幕的问题。但是<code>GalGame</code>类的游戏就工作正常。</p><p>总的来说，这次切换到<code>hyprland</code>的使用体验还是非常不错的，平铺式窗口管理器也是提高生产力的利器。</p><h3 id="Hyprland仍不完善"><a href="#Hyprland仍不完善" class="headerlink" title="Hyprland仍不完善"></a><code>Hyprland</code>仍不完善</h3><p>有得必有失，<code>hyprland</code>乃至于<code>wayland</code>目前作为一个桌面环境最大的问题就是相关生态仍不完善。这里的生态甚至都不是指对于<code>wayland</code>支持之类的东西，而是像系统设置、锁屏界面、状态栏之类的东西。虽然这样说可能有点对于<code>hyprland</code>的要求过高了，但是现在这种东拼西凑的构成一个桌面环境给人的体验不是很好，譬如使用<code>waybar</code>作为状态栏，<code>swaylock</code>作为锁屏界面，<code>kwallet</code>作为密码存储器。其中不少软件还都处于一个十分简陋的阶段，例如<code>swaylock</code>仅显示一张图片作为界面，甚至连个输入密码的界面都没有。</p><p><code>hyprland</code>对于弹出窗口的支持不是很好，尽管这就是平铺式窗口管理器的设计思想。但是在像<code>idea</code>之类的编程工具中，弹出窗口是非常常用的功能，不能正常的显示弹出窗口或者显示的位置不对会导致严重的生产力下降。经过测试，当只使用一个显示屏是，可以正常的进行弹出窗口的显示，但是当链接多个显示器时，弹出窗口的位置就变得奇怪起来。</p><h2 id="amdgpu导致的相关问题"><a href="#amdgpu导致的相关问题" class="headerlink" title="amdgpu导致的相关问题"></a><code>amdgpu</code>导致的相关问题</h2><p>从我在这台电脑上安装<code>Linux</code>之后，便一直会出现图形界面卡死的问题。具体表现为图形界面停止响应，但是通过<code>ssh</code>等仍能正常远程链接，大小写锁定正常，使用<code>Ctrl+Alt+F3</code>组合键切换到其他<code>tty</code>的方式有一定的概率可以从卡死中恢复，但是也存在一定的可能性只能通过强制重启解决。</p><p>通过分析日志中的错误信息，大致锁定一下几个<code>issue</code>可能和这个问题有关：</p><ul><li><a href="https://gitlab.freedesktop.org/drm/amd/-/issues/2443">random amdgpu hangs</a></li><li><a href="https://gitlab.freedesktop.org/drm/amd/-/issues/2006">flip_done timeout</a></li><li><a href="https://gitlab.freedesktop.org/drm/amd/-/issues/2220">ring sdma0 timeout</a></li></ul><p>同时在<code>raddit</code>和<code>archlinux forum</code>上都存在大量的讨论，均是怀疑为内核的问题。总结一下，这个问题似乎和较新版本的内核和AMD的新<code>rdna2</code>显卡有关，同时是否链接外接显示器也有着不同的故障表现。而且，随着<code>linux kernel</code>不断的升级，报错信息似乎也在变化，<del>虽然因为我的系统日志被自动覆盖，不能提供详尽的日志信息</del>。</p><p>在某一篇讨论中（很抱歉我忘记了具体页面）有人指出这可能和内核对于CPU电压的调控有关，在切换到AMD新发布的CPU频率调节驱动<code>amd p-state</code>之后，这个问题就不再出现了。查询<a href="https://wiki.archlinux.org/title/CPU_frequency_scaling">wiki</a>可以发现，这个驱动目前并没有默认驱动，而是需要通过添加内核参数的方式启动。我使用<code>grub</code>作为启动程序，在配置文件<code>/etc/default/grub</code>的<code>GRUB_CMDLINE_LINUX_DEFAULT=</code>末尾添加新的启动参数<code>amd_pstate=active</code>，重启之后查看当前驱动：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">❯ cat <span class="hljs-regexp">/sys/</span>devices<span class="hljs-regexp">/system/</span>cpu<span class="hljs-regexp">/cpu0/</span>cpufreq/scaling_driver<br>amd-pstate-epp<br></code></pre></td></tr></table></figure><p>目前我已经启动这个新的驱动程序一周时间了，上述问题没有在出现过。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日用Linux挑战第1篇</title>
    <link href="/blog/2023/03/08/daily-linux-1/"/>
    <url>/blog/2023/03/08/daily-linux-1/</url>
    
    <content type="html"><![CDATA[<h1 id="日用Linux挑战第1篇"><a href="#日用Linux挑战第1篇" class="headerlink" title="日用Linux挑战第1篇"></a>日用Linux挑战第1篇</h1><p>从去年12月底正式切换到<code>Linux</code>开始算起，我日常使用<code>Linux</code>已经过去了2个月的时间。在本系列的上一篇文章——<a href="https://rrricardo.top/blog/2023/01/15/daily-linux-0/">日用Linux挑战 第0篇 - Ricardo的博客</a>中，我讲述了我配置自己的<code>Arch Linux</code>的过程，还小小的赞扬了一波<code>Linux</code>在近些年来取得的进展。但是在这篇文章中，我将重点指出日常使用过程中遇到的问题和困难。</p><span id="more"></span><h2 id="尝试迁移到Wayland"><a href="#尝试迁移到Wayland" class="headerlink" title="尝试迁移到Wayland"></a>尝试迁移到Wayland</h2><p>众所周知，<code>X11</code>已经是一个落后和过时的显示协议，目前更新的显示协议<code>Wayland</code>正在尝试干掉它，但是由于<code>X11</code>长期使用带来的稳定性，这种工作并不是那么容易。现在是2023年，<code>Wayland</code>的工作进展到了何种程度？</p><p>我使用<code>KDE</code>作为我的桌面环境。<code>KDE</code>已经有了基础的<code>Wayland</code>支持，在启动界面选择<code>Wayland</code>会话就可以正常进入。</p><p>虽然在切换到<code>Wayland</code>会话之后，除了<code>KDE</code> 自带的应用程序，日常使用的大部分应用程序还是运行在<code>xwayland</code>之下，例如<code>edge</code>和<code>firefox</code>浏览器，<code>VSCode</code>等。</p><p>在<code>/etc/environment</code>中设置<code>MOZ_ENABLE_WAYLAND=1</code>可以<code>firefox</code>切换到<code>Wayland</code>会话下，运行正常。</p><p>在<code>~/.config/microsoft-edge-stable-flags.conf</code>添加<code>--ozone-platform-hint=auto</code>将<code>edge</code>切换到<code>Wayland</code>下，运行正常。</p><p>然而存在的问题也不少。</p><ul><li><p><code>sddm</code>窗口管理器在关机的时候没法正常的关闭，导致每次关机都需要等待1分30秒。</p><p>而且这是一个<code>sddm</code>的问题，从<a href="https://github.com/sddm/sddm/issues/1476">相关Issue</a>上看，这个问题已经在<code>master</code>分支被修复了，只是在相关发行版中还没有修复。</p><p>采用切换到<code>sddm-git</code>的方式修复了这个问题。</p><blockquote><p>而且在<code>archlinuxcn</code>仓库里面还有这个包，赞美<code>archlinuxcn</code>。</p></blockquote></li><li><p><code>ibus-rime</code>输入法在<code>Wayland</code>下的适配也是非常的糟糕，甚至是一种不稳定的糟糕，每次出现的问题都不一样，比如现在的问题就是在<code>Edge</code>浏览器下无法使用。</p><p>在更换使用<code>fcitx-rime</code>框架之后稍微好了一点，至少能用了（</p></li><li><p>部分网站的登录信息丢失。</p></li><li><p>使用<code>BiliBili</code>全屏播放视频的时候，只要鼠标移入全屏的范围，画面就会黑屏。可能和我使用双显示器有一定的关系。</p></li><li><p>使用<code>125%</code>的整体缩放比例的时候，字体处于一种模糊的状态，看上去很不舒服。</p></li></ul><p>简单的说，我不认为现在<code>Linux</code>已经准备好切换到<code>Wayland</code>下了。</p><blockquote><p>听说最精<code>Ubuntu 22.04</code>已经默认使用<code>Wayland</code>作为显示协议了，等我有了其他的电脑可以试一试，看看商业公司的加入能不能带来一点转机。</p></blockquote><h2 id="使用中发现的问题"><a href="#使用中发现的问题" class="headerlink" title="使用中发现的问题"></a>使用中发现的问题</h2><h3 id="双屏使用的问题"><a href="#双屏使用的问题" class="headerlink" title="双屏使用的问题"></a>双屏使用的问题</h3><p>最近入手了一块2K 75Hz的VA显示屏，本来打算美滋滋的使用双屏高效率的<del>摸鱼</del>学习，结果发现问题实在是非常的一言难尽。</p><ul><li><p>我的两块屏幕的分辨率不是完全一致的，笔记本自带的屏幕是3:2的2160x1440，而新买的显示屏是16:9的2560x1440。这就导致两块屏幕的纵向分辨率是一致的，而横向分辨率是不同，这点似乎迷惑了<code>KDE</code>的相关处理程序，导致两块屏幕各有一个部分显示在另外一块屏幕上<del>虽然有点抽象，但是我相信你能够想象出来，如果我再次遇到我一定会补一张图的</del>。虽然这个问题通过重新设置<code>Display configuration</code>就可以解决，但是真的很好笑。</p></li><li><p>部分程序也会因为上面的分辨率不同而导致部分意料之外的情况。比如原神，不如画面整体被横向压缩而出现一大堆椭圆，就是画面的两端有黑边，导致现在我玩原神都是合上笔记本显示屏玩。</p></li></ul><blockquote><p>看来以后想在<code>Linux</code>想使用双屏需要购买两块分辨率完全一致的显示屏。</p></blockquote><ul><li>程序在两块屏幕上的显示完全是混乱的。比如我打开<code>IDEA</code>，启动界面显示在一块屏幕上，选择项目之后的编辑界面又会出现在另外一块屏幕上。</li></ul><h3 id="Wine-96-键盘按键不停重复的问题"><a href="#Wine-96-键盘按键不停重复的问题" class="headerlink" title="Wine&#96;键盘按键不停重复的问题"></a>Wine&#96;键盘按键不停重复的问题</h3><p>在某次<code>sudo pacman -Syu</code>之后，我遇到一个奇怪的现象——在打原神的时候，如果较长时间的按下某一个按键，那么那个按键就会不停的重复，就像没有弹起一样。例如我按下<code>W</code>键较长时间再松开，人物仍然会前进，就像我没有松开一样。</p><p>当时我的解决办法是在系统设置里临时关闭了<code>When a key is held</code>选项再进行游戏。通过查看<code>pacman</code>的更新日志，我以为是<code>plasma</code>更新的问题。</p><p>在之后的某天中，为了折腾<code>Wayland</code>，我把输入法从<code>ibus</code>框架切换到了<code>fcitx5</code>框架，惊喜的发现这个问题消失了。</p><p>那么新的问题出现了：这个问题到底是为啥出现捏？不过本着多一事不如少一事的精神，我选择能跑就行，管它为什么。</p><h2 id="赞美Kde-Connect"><a href="#赞美Kde-Connect" class="headerlink" title="赞美Kde Connect"></a>赞美Kde Connect</h2><p>作为一个大学牲，在自己的不同设备之间频繁的传送文件自然是家常便饭。在进入<code>Linux</code>之前，我几乎都是使用<code>QQ</code>在我的手机、iPad和笔记本电脑之间共享文件，属于是究极折磨。入境大力拥抱<code>Linux</code>和<code>KDE</code>，没想到还有意外收获——<code>KDE connect</code>。在手机和iPad和笔记本电脑上安装和互相配对之后，不同的设备之间就可以方便的发送和接受文件了。妈妈再也不同担心我传送文件的难题了。</p><p>好了下次攒够一波问题和经历在更新新一期Linux日用挑战。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日用Linux挑战 第0篇</title>
    <link href="/blog/2023/01/15/daily-linux-0/"/>
    <url>/blog/2023/01/15/daily-linux-0/</url>
    
    <content type="html"><![CDATA[<h1 id="日用Linux挑战-第0篇"><a href="#日用Linux挑战-第0篇" class="headerlink" title="日用Linux挑战 第0篇"></a>日用Linux挑战 第0篇</h1><p>在将开发重心移到<code>WSL</code>上一年之后，我最终还是决定完全抛弃Windows，转向使用Linux作为我日常使用的主力系统。目前，我已经使用Linux作为主力系统一个月了。</p><span id="more"></span><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><h3 id="电脑"><a href="#电脑" class="headerlink" title="电脑"></a>电脑</h3><p>首先介绍一下用来安装Linux系统的电脑——荣耀的<code>Magicbook 14</code>，我今年秋天才购入的轻薄笔记本。</p><ul><li><p>CPU：R7-6800H</p></li><li><p>内存：DDR5 6400MHz 16GB</p></li><li><p>硬盘: 西部数据 SN550 1T</p></li></ul><blockquote><p>硬盘为我自行更换，原装的盘被我搞掉盘了（笑）</p></blockquote><p>其他的像网卡啥的我就不一一介绍了，具体的硬件兼容性我后面会专门说明。</p><h3 id="选择发行版"><a href="#选择发行版" class="headerlink" title="选择发行版"></a>选择发行版</h3><p>众所周知，选择Linux最重要的一步就是选择一个适合自己的Linux发行版。在正式将Linux作为主力系统之前，我使用的比较多的发行版是<code>Ubuntu</code>，在<code>WSL</code>、服务器和树莓派上我都是使用的它。</p><p>不过这次，我选择了<code>Arch</code>发行版。虽然这个发行版不像<code>Ubuntu</code>一类的发行版提供了开箱即用的使用体验，而且安装<code>Arch</code>的过程也很难称作简单，但是经过两年半<del>小黑子露出了鸡脚</del>的Linux练习之后，我对于命令行界面的使用还是比较熟悉了。而且<code>Arch</code>还提供了其他一些非常吸引我的点：</p><ul><li><p>默认的<code>Arch</code>安装是一个极简的操作系统，甚至没有图形化的界面，这就提供了一个非常大的优点——不会有任何预装的垃圾</p></li><li><p><code>Arch</code>采用滚动升级模型，尽全力让所有的软件包都保持在最新，而我恰好使用的是比较新的硬件，为了避免出现兼容性的问题，我希望能够使用最新的<code>Linux</code>内核和软件<del>虽然我实际测试，Ubuntu等系统也能正常使用</del></p></li><li><p><code>Arch</code>还提供了一个由用户维护的软件安装源——<code>AUR</code>，一些没有进入官方软件源的软件可以方便的在这里一键安装，非常的好用，非常的方便</p></li><li><p><code>Arch</code>还提供了一份非常详尽的<code>wiki</code>文档</p></li></ul><h3 id="选择桌面环境"><a href="#选择桌面环境" class="headerlink" title="选择桌面环境"></a>选择桌面环境</h3><p>我在Linux系统中长时间使用过的桌面环境有<code>GNOME</code>和<code>KDE</code>两种。</p><p>我首先安装的是<code>gnome</code>这个桌面环境，在使用的过程中常常会遇到桌面卡死的情况，切换到其他的<code>tty</code>重启<code>gdm.service</code>之后就能恢复，在尝试修复无果之后我就切换到了<code>KDE</code>桌面环境，目前用上还算满意。</p><h2 id="Hello-Linux"><a href="#Hello-Linux" class="headerlink" title="Hello, Linux!"></a>Hello, Linux!</h2><h3 id="安装Arch"><a href="#安装Arch" class="headerlink" title="安装Arch"></a>安装Arch</h3><p>按照<code>wiki</code>上的安装教程，安装的过程还算的上是比较的顺畅，大概90分钟的时间完成了我的第一次<code>Arch</code>安装。</p><p>不过在安装的过程中，有些问题需要注意：</p><ul><li><p>虽然官方Wiki有着中文翻译的版本，但是在参考的时候需要注意查看同英语原文之间有没有滞后的内容，<code>Arch</code>作为一个滚动更新的版本，安装的方法也常常发生变化。</p></li><li><p>在我下载的安装镜像中的<code>pacman mirrorlist</code>文件中并没有大陆常用镜像服务器的地址，需要手动添加。我添加了清华大学和浙江大学两个镜像站的地址。</p></li><li><p>如果没有有线的网络链接，记得在系统中安装联网所需要的程序，比如<code>NetworkManager</code>啥的，否则你安装完成之后发现没有办法联网，只能再次从安装镜像启动再安装相关的软件。</p></li></ul><h3 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h3><p>在安装桌面环境之前，先安装显卡的驱动程序。</p><p>参考文档，需要安装<code>mesa</code>、<code>lib32-mesa</code>和<code>vulkan-radeon</code>三个软件包，其中<code>lib32-mesa</code>软件包是对32位程序提供支持的软件包，为了安装这个软件包需要打开<code>multilib</code>这个仓库，取消<code>/etc/pacman.conf</code>这个文件中对于<code>[multilib]</code>部分的注释来实现这个功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S mesa lib32-mesa vulkan-radeon<br></code></pre></td></tr></table></figure><p>由于使用的是<code>KDE</code>桌面环境，这个桌面环境对于<code>wayland</code>显示服务器的支持还不算太好，于是首先安装<code>xorg</code>显示服务器和显示驱动程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S xorg-server<br></code></pre></td></tr></table></figure><p>然后安装桌面和<code>sddm</code>显示管理器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S plasma sddm<br>sudo systemctl enable sddm.service<br></code></pre></td></tr></table></figure><p>重启之后图形界面就可以正常显示了。</p><h4 id="桌面环境的美化"><a href="#桌面环境的美化" class="headerlink" title="桌面环境的美化"></a>桌面环境的美化</h4><p>都在使用<code>Arch</code>了，不折腾一下桌面环境的美化是不可能的。</p><p>我目前实现的效果大概长这样：</p><p><img src="/blog/2023/01/15/daily-linux-0/2023-01-12-13-28-38-Screenshot_20230112_132829.png"></p><p>颇有一种<code>Windows</code>和<code>MacOS</code>杂交的风格。</p><p>使用的主题地址为<a href="https://github.com/vinceliuice/WhiteSur-kde">GitHub - vinceliuice&#x2F;WhiteSur-kde: MacOS big sur theme for kde plasma</a>，添加了一个<code>Windows 10</code>风格的开始菜单插件<a href="https://github.com/Zren/plasma-applet-tiledmenu">GitHub - Zren&#x2F;plasma-applet-tiledmenu</a>，字体是直接从<code>Windows</code>下面复制过来的<code>Microsoft YaHei UI</code>。</p><blockquote><p>顺便提一下，我发现安装kde主题最快的方式是找到主题的Github仓库，<code>clone</code>之后安装。这种方法比去折腾那个不好用的主题商店快一万倍。</p></blockquote><p>目前在美观上还存在的缺憾是登录界面和锁屏界面我还没有去折腾，还是默认的样子。</p><h3 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h3><p>先上一张<code>shell</code>的系统概览截图：</p><p><img src="/blog/2023/01/15/daily-linux-0/2023-01-12-13-36-45-Screenshot_20230112_133628.png"></p><p>终端模拟器直接使用的<code>konsole</code>，目前没有进行改动。</p><p>系统中使用的输入法是<code>ibus</code>框架下的<code>rime</code>输入法，词库不太智能。浏览器使用的<code>edge</code>，几乎完全复制了我在Windows下的体验；邮件客户端我使用的<code>ThunderBird</code>，不过没法后台通知；<code>Markdown</code>写作使用的是<code>MarkText</code>，几乎可以取代<code>Typora</code>；腾讯在2022年的12月30日发布了新版的<code>QQ</code>，也算是补上了Linux上一个比较大的短板，不过目前的支持还是比较差，甚至连收发文件都不支持。至于<code>office</code>办公软件，我的需求不是很明显，采用<code>onedrive</code>和<code>Microsoft 365</code>在浏览器端基本上解决了。编程方面，<code>VSCode</code>和<code>Jetbrains</code>这两个我主力的IDE都能在Linux下正常的工作。在游戏方面上，我最近玩的<code>Hearts of Iron 4</code>有着Linux原生的版本，运行流畅，而<code>原神</code>也在利用一些小手段和<code>wine</code>之后，比较流畅的运行起来了，至于<code>Steam</code>提供的<code>Pronton</code>兼容层，还没怎么用过。</p><h3 id="发现的兼容性问题"><a href="#发现的兼容性问题" class="headerlink" title="发现的兼容性问题"></a>发现的兼容性问题</h3><p>显然，目前的Linux也不可能做到尽善尽美。</p><ul><li><p>在睡眠之后，电脑没有办法正常的播放声音，应该是内核中对于新硬件的支持问题。</p></li><li><p>指纹识别失效了。<code>fprint</code>库上还没有提供对我这个硬件的支持。<del>也有可能永远不会提供</del></p></li><li><p>笔记本方面的支持还是有所欠缺，也有可能是因为我的调教还不到位。出现过几次合上盖子之后没有办法唤醒的问题，最后只能强制关机后重启。</p></li></ul><h2 id="日常使用一个月"><a href="#日常使用一个月" class="headerlink" title="日常使用一个月"></a>日常使用一个月</h2><p>作为一个程序员，<code>Arch Linux</code>确实非常适合我使用。还记得在折腾<code>WSL</code>的时候，<code>jetbrains</code>的IDE写代码的时候bug非常多，只有<code>VSCode</code>的支持稍微好一点，但是作为一个<code>IDE</code>的功能又不是很强大。<code>WSL</code>还有着一堆兼容性的问题，我还记得在<code>WSL</code>脱离<code>preview</code>标志之后，我有好几次一启动<code>WSL</code>就蓝屏的经历，属实难忘。</p><p>不过使用Linux还是有很多不方便的地方，尤其是在国内办公软件的兼容性问题上。虽然很多国产软件都提供了Linux的版本，不过一般都是统信UOS或者是麒麟Kylin版本的，为了在Arch Linux上运行还需要自己研究一下。在这里我要点名批评”Q*”软件，其从官网上下载的<code>AppImage</code>格式的程序文件中还有错误，内附的<code>qq.desktop</code>文件中的图片路径竟然是写死<code>/opt/...</code>。我的评价是做程序的人还是用点心罢，至少打包完成了还是自己测试一遍罢。</p><p>平心而论，目前的Linux已经可以成为一个日常使用的操作系统了。虽然仍然不能完全摆脱命令行界面，普通用户按照<code>Windows</code>下的使用经验来使用还存在一定的困难，但是如果你是计算机相关从事人员而且对游戏没有太大的依赖，<code>Linux</code>是一个不错的选择。</p><p>不出意外的话，本文将是一个系列文的第一篇。我将定期更新这个系列，记录我在学习和工作中使用<code>Linux</code>的体验和感受。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原神抽卡研究一</title>
    <link href="/blog/2022/12/31/genshin-gacha-1/"/>
    <url>/blog/2022/12/31/genshin-gacha-1/</url>
    
    <content type="html"><![CDATA[<h1 id="原神抽卡研究一"><a href="#原神抽卡研究一" class="headerlink" title="原神抽卡研究一"></a>原神抽卡研究一</h1><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前在市面上出现了大量以抽奖为核心盈利手段的电子游戏，在这种游戏中，获取游戏中的物品不是明码标价的购买，而是通过参加某种抽奖性质的活动。玩家花费一定金额购买参加活动的机会，每次参加都有一定的概率获得玩家想要获得的物品。在抽奖活动中，游戏设计者还会引入一种被称为 “保底” 的游戏机制：开发者向玩家群体承诺在一定的参加次数之后必然会获得到该物品。例如下面是热门游戏《原神》中获取游戏中角色 “抽奖” 活动的概率公示页面。</p><p><img src="/blog/./genshin-gacha-1/2022-12-31-13-06-36-image.png"></p><p>在这个 “抽奖” 活动中，玩家可以得到三种等级的物品，在游戏中分别称为 “五星物品”、“四星物品” 和 “三星物品”。在每次的 “抽奖” 活动中，玩家必定会获得上述三种物品中的一种。为了简化问题的讨论，我们现不区分相同等级不同物品之间的不同，只考虑不同星级物品的获取概率。通过概率公示可以知道：五星物品的 “基础概率” 为0.600%，四星物品的 “基础概率” 为 5.100%；五星物品的 “综合概率” 为 1.600%，四星物品的 “综合概率” 为 13.000%。从一个玩家的角度出发，自然会存在两个问题：</p><ul><li><p>什么是“基础概率”，什么是“综合概率”？</p></li><li><p>游戏中的实际概率和公式概率吻合吗？</p></li></ul><h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><p>在大量的重复实验中，事件 A 发生的频率往往具有稳定性，随着重复实验次数的增加，事件发生的频率逐渐稳定于某个固定的客观的常数。由于大数定理，频率最终会收敛到概率。因此，可以通过大量玩家参与这个 “实验” 的数据来回答上述的问题。</p><h3 id="数据的获取"><a href="#数据的获取" class="headerlink" title="数据的获取"></a>数据的获取</h3><p>一般而言，游玩游戏的玩家只能看见自己过往参加游戏时的记录，但是在一些第三方平台上允许其他玩家主动上传数据并公示给大家。虽然这些第三方平台上数据不能完全保证可靠性，可以通过统计中筛选删除明显错误和容易对结果产生较大影响的数据，即使仍然存在少量的错误数据也不会对结果产生比较明显的影响。这里采用<a href="https://github.com/OneBST">OneBST</a>从第三方平台 <a href="https://feixiaoqiu.com/">“非小酋” 网站</a>获取的截至 2022 年 7 月 26 日的数据作为数据集。</p><blockquote><p>数据可以在<a href="https://github.com/OneBST/GI_gacha_dataset/">Github仓库</a>中下载。</p></blockquote><h3 id="数据的统计和分析"><a href="#数据的统计和分析" class="headerlink" title="数据的统计和分析"></a>数据的统计和分析</h3><p>利用 Python 中的 Numpy 和 Pandas 等工具包对获取到的数据进行统计分析，在对获取到的数据进行分析的过程中按照以下的规则排除明显错误和对结果影响比较大的数据：</p><ul><li><p>抽卡中多次出现违反“保底”规则的数据，例如多次获得“四星”物品的间隔超过10次。</p></li><li><p>数据中应该唯一的字段“gacha_id”大量重复。</p></li><li><p>第一次获得四星或者五星物品。</p></li><li><p>数据本身的错误。</p></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="综合概率的解释"><a href="#综合概率的解释" class="headerlink" title="综合概率的解释"></a>综合概率的解释</h3><p>在总共 4842256 次抽卡记录中，获得五星物品的次数为 78493 次，于是：</p><p><img src="/blog/genshin-gacha-1/2022-12-31-15-59-20-image.png"></p><p>再计算一下每次参加该活动获得四星物品的平均概率：在总共 5000139 次抽卡中，获得四星物品的次数为 653200：</p><p><img src="/blog/genshin-gacha-1/2022-12-31-15-59-42-image.png"></p><p>不难发现，在误差允许的范围内，计算出来的平均概率和游戏开发者所公布的 “综合概率” 是相同的。当参与这个游戏足够多次时，获取到五星物品和四星物品的数量就可以用这个概率来估计。</p><h3 id="抽卡过程的数学描述"><a href="#抽卡过程的数学描述" class="headerlink" title="抽卡过程的数学描述"></a>抽卡过程的数学描述</h3><p>为了方便讨论，再次将这个 “游戏” 简化为获得五星物品和不获得五星物品两种情况。那么这个 “抽奖” 游戏是否就能被简化为一个概率为 1.6% 的 n 次伯努利实验？不妨假设每次获得五星物品之间相互独立，这样每次获得五星物品都可以认为是首次获得五星物品，这时参加该游戏的次数就会符合概率为 1.6% 的几何分布，而为了符合保底规则，当玩家在参与到第 90 次时仍未获得五星物品，强制给予玩家一个五星的物品。画出实际数据中得到的图像和按照几何分布得到的图像。</p><p><img src="/blog/genshin-gacha-1/2022-12-31-13-20-46-image.png"></p><p><img src="/blog/genshin-gacha-1/2022-12-31-13-21-11-image.png"></p><p>不难发现假设的猜想和实际情况不相符合。在抽数小于 73 抽时，获得五星物品的概率逐渐降低，从 0.6% 左右一直降低至 0.4% 左右。当抽数大于等于 73 抽时，抽到的概率开始上升，在抽数等于 77 抽时达到最大，大约为 10.4%。随后概率开始下降，在第 91 抽时，概率等于 0。</p><p>如果在实际得到的概率关于抽数的图上再作出概率为 0.6% 的几何分布的图像，前73 抽的概率图像和几何分布的图像几乎吻合。也就是说，该抽奖游戏的前 73 抽就是一个符合 P &#x3D; 0.6% 的几何分布，从第 73 抽开始 “保底” 机制的修正。这就是游戏开发者口中 “基础概率” 的含义：在该抽奖游戏的前数十抽就是一个概率为 0.6% 的伯努利实验。</p><p><img src="/blog/genshin-gacha-1/2022-12-31-13-24-26-image.png"></p><p>从大量的实际数据出发，不难发现游戏开发者的申明同实际情况相吻合。</p><h2 id="不足和展望"><a href="#不足和展望" class="headerlink" title="不足和展望"></a>不足和展望</h2><h3 id="获取五星物品相互独立的假设"><a href="#获取五星物品相互独立的假设" class="headerlink" title="获取五星物品相互独立的假设"></a>获取五星物品相互独立的假设</h3><p>直到作者开始写作本文之前，作者都没有意识到本文 3.2 节中的所有结论几乎都基于该假设。限于文章的篇幅原因和个人的能力问题，在本文中未对这个假设作出验证。下面给出一种验证该猜想的方法。为验证获得五星物品之间相互独立，可以通过统计方法验证下面的等式成立。</p><p><img src="/blog/genshin-gacha-1/2022-12-31-16-00-10-image.png"></p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>在获得概率和抽数之间的相关关系之后，可以将这个抽卡的过程当作一个随机过程进行析，并且求出相关的数学特征。从玩家的角度出发，可以指导玩家使用比较合理的策略参加这个游戏，从而以比较低的代价获得自己心仪的物品。从游戏开发者的角度出发，则有有利于优化自己游戏中的概率设计，吸引更多的玩家参与到游戏中来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>原神</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年终总结</title>
    <link href="/blog/2022/12/30/2022-final/"/>
    <url>/blog/2022/12/30/2022-final/</url>
    
    <content type="html"><![CDATA[<h1 id="2022年终总结"><a href="#2022年终总结" class="headerlink" title="2022年终总结"></a>2022年终总结</h1><p>2022是困难的一年。我们需要为2023年做好准备。</p><span id="more"></span><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽管人们在撰写年终总结时习惯于”美化“过去一年的境遇，但是2022年的情况让我甚至很难用”砥砺奋进”或者“破浪前行”之类的词来形容。</p><p>导致2022年这种情况的原因很复杂，国际大气候的惊涛骇浪和国内小气候的暗流涌动、新型冠状病毒疫情的反复延续以及我个人的部分特殊情况都能算在其中。</p><p>2022年绝对是见证历史的一年，而且是大部分人不想见证的历史。2022年2月，俄乌冲突爆发；7月前日本首相安倍晋三被刺杀；8月佩洛西窜访台湾；12月巴尔干半岛剑拔弩张。而新型冠状病毒肺炎的防控遭遇重大挫折，我们离回到正常的生活更是遥遥无期。“百年未有之大变局”这个提法在2017年末的时候出现，在那个时候可能只有少数人明白啥叫“大变局”，如今5年过去了，可能大家都明白了什么叫做“大变局”。</p><blockquote><p>鉴证不是为了过过嘴瘾，而是为了更好的指导自己的生产生活实际。</p></blockquote><h3 id="时长八个月的寒假"><a href="#时长八个月的寒假" class="headerlink" title="时长八个月的寒假"></a>时长八个月的寒假</h3><p>2021年末12月，新冠Omicron变异株在南非首次被检出，随即得到命名。在那个时间点上我还不如现在这般关注新变异株的出现和提交，也不会知道这个变异株会直接摧毁我在2022年上半年的生活。2022年1月3日我离开学校回到家中，而我下一次回到学校，就要到8月27日了。</p><p>在这8个月的前半段似乎还一切正常。首先是应付因为冬奥会而改成线上的期末考试，说来也是奇妙，进入大学已经3个学期了，我还没有在线下参加过期末考试。然后就开始宅在家的寒假，过完一个平淡的年。随着年味散去就开始期待开学的日期，但是等来的却是一次次的推迟通知——吉林疫情，上海疫情，北京疫情，随着疫情在一个个地点爆发，我们终于意识到自己大学的第二个学期只能完全在家里度过了。</p><p>不过讲道理，在家里学习和在学校里学习的孰优孰劣是一个值得探讨的问题。我个人认为，还是在学校里更加的适合学习。学校可以为你提供生活中所需要的一切——食堂、宿舍和图书馆。还有最为重要的安静氛围。北邮的沙河校区我就非常的喜欢，现代化的校区位于僻静的郊外，简直就是学习的圣地。但是像本部之类的地方还是尽快从地球上消失好一点——全校共用的公共澡堂、永远没有位置的图书馆简直就是上世纪八十年代的大学校园，在这里学习是一种挑战。至于在家里学习，我的评价是吾其还也。</p><blockquote><p>关于这八个月我有一个更加详细的总结，我在这里就不赘述了。</p></blockquote><h3 id="搬校区-amp-大二"><a href="#搬校区-amp-大二" class="headerlink" title="搬校区&amp;大二"></a>搬校区&amp;大二</h3><p>进入8月份，国内的疫情终于趋稳，开始准备回到阔别已久的校园。</p><p>可是关于返校的第一个消息就是我们要从美好的沙河校区搬到傻逼的本部——这不仅仅是一个空间上的移动，更是一种时间上的移动——沙河校区兴建与2015年，而本部则是上个世纪的遗产。</p><blockquote><p>这里插播本部笑话二则。</p><ul><li><p>欢迎来到北京邮电大学西土城校区，这里有上世纪八十年代北京最好的大学宿舍。——北京邮电大学招生广告</p></li><li><p>年近耄耋的老校友走进学生二公寓，拉了一下墙上的拉绳开关，灯亮了，老校友激动的感叹到”还和我当年住的时候一模一样“。——校庆日见闻</p></li></ul></blockquote><p>很高情商的说，在本部生活有一种历史的厚重感。特别是你在教室上课的时候注意到墙上展示五十年前校风光的照片上展示的教学楼和你现在正在待的教学楼一模一样时，特别是你晚上提着桶穿过半个校园去洗澡时，特别是你参观老式办公楼一般的图书馆时。</p><p>虽然本部确实挺垃圾的，但是吐槽还是得有个限度。</p><p>大二一开始是就是大一学年的综合评价。我对此的评价是希望信息黄埔还是做点信息黄埔该做的的事情吧，不要搞得大家天天骂你信息黄泉，明明可以直接让系统自动生成的东西还需要自己手动填写，简直就是垃圾。</p><p>在综合评价完成之后，奖学金的评选和专业分流就是顺理成章的事情了。小小的从学校赚了一笔钱，成功进入了自己心仪的计算机科学与技术专业，从这个方面上来看，本学期还算是顺利。</p><p>然后是学生组织。执行自己在上半年使所指定的规划，从院团委的宣传部门跳槽出来，加入了传说中北邮最神秘的学生组织——北邮人。<del>虽然就目前来看，北邮人略显的有点那啥</del>。</p><p>然后是大创。作为业界知名的PPT大赛，而且还能够在综合评价的时候加分，这种你好我好大家好的东西自然是应参加尽参加，<del>我对于自己大一忘记水一次的这种事情表示：当事人很后悔</del>。</p><p>小小的总结一下：2022年可以算得上是一事无成的一年，还搞砸了不少的事情。在写代码上进展有限，成绩上大幅倒退，说好的六级英语和大学物理竞赛都没有参加，在年末应对疫情进展的时候更是把“不知所措”这个成语诠释的淋漓尽致。</p><p><img src="/blog/2022/12/30/2022-final/2022-12-30-14-26-19-QQ_Image_1672381538441.jpg"></p><p>关于今年的人际交往和社会关系，我愿意用QQ2022年年终总结中的一张截屏来总结，这张图片透漏出一种无可救药的悲伤。</p><p><img src="/blog/2022/12/30/2022-final/2022-12-30-14-28-12-QQ_Image_1672381543836.jpg"></p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>2023年很有可能还是极为困难的一年，不过有了2022年的前车之鉴，我相信我们可以在2023年取得比较辉煌的成就。</p><p>在思想上，我们提高自己认识困难，处理困难的思想和意识。要摒弃被动迎战的“怕事”思维，积极主动地按照形势的变化做准备。</p><p>在疫情的防控方面，我们需要尽快的适应新的疫情流行形势下的工作学习和生活，坚持以科学为导向，坚持生活至上的原则，在保证自己的生命安全的前提之下，尽量的维持原有的生活和学习习惯。在被动适应的同时我们还要主动出击，将工作做在前面，提高自己应对这种黑天鹅事件的能力。积极主动的关心新变异株的流行趋势，预计下一次疫情高峰，采取有力措施避免同病毒正面硬刚。提高自己的防护意识和防护水平，尽量避免一切可能的高危暴露。</p><p>在个人的学习方面，坚持学习是为了能力而不是为了分数的思想指引。关注个人实际能力和水平的提升，不要将时间浪费在无意义的竞争之上。采取信息化的措施优化自己的时间管理、目标管理，坚持利用信息化的方法管理自己学到的知识，坚持利用信息化的途径进行学习。要更多的对未来进行前瞻性的思考，通过文字的方式记录自己的思考成果，在这里方面要“务虚”而不是“务实”，更多的对前进的方向进行大方向上的把握。</p><p>我们相信，2023年将是收获的一年。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译MediaPipe框架</title>
    <link href="/blog/2022/11/11/compile-mediapipe/"/>
    <url>/blog/2022/11/11/compile-mediapipe/</url>
    
    <content type="html"><![CDATA[<h1 id="编译MediaPipe框架"><a href="#编译MediaPipe框架" class="headerlink" title="编译MediaPipe框架"></a>编译MediaPipe框架</h1><span id="more"></span><p>最近开始研究自己的大创项目，一个关于动作捕捉的小玩意儿，第一步就是<del>抄袭开源代码</del>借鉴他人优秀成果。在众多的项目中，我看上了这个Google开源的优秀框架，先把这个项目在本地上跑起来再说。这篇文章就记录了我编译这个框架的过程。</p><blockquote><p>在我写完这篇文章之后，我就从<code>WSL</code>润到了<code>Arch Linux</code>，然而我还是有编译<code>MediaPipe</code>的需求，所以这篇文章就增加了<code>Arch Linux</code>下编译<code>MediaPipe</code>的过程。</p></blockquote><p>首先是在<code>Arch Linux</code>下编译的过程。</p><h2 id="编译环境概述"><a href="#编译环境概述" class="headerlink" title="编译环境概述"></a>编译环境概述</h2><p>使用<code>Arch Linux</code>，需要注意的是<code>Arch Linux</code>采用滚动更新，目前的安装方法可能在不久的将来就不适用了。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>首先安装<code>bazelisk</code>，由于我安装了<code>pnpm</code>，直接使用<code>pnpm install -g @bazel/bazelisk</code>安装。</p><p>然后使用<code>pacman</code>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S opencv ffmpeg jdk-openjdk git<br></code></pre></td></tr></table></figure><p>还有编译的过程中可能会涉及到<code>python</code>中的<code>numpy</code>软件包，我由于已经安装了<code>conda</code>来管理<code>python</code>环境，于是就采用<code>conda install numpy</code>在<code>base</code>环境中安装。</p><p>克隆<code>MediaPipe</code>仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/google/mediapipe.git<br></code></pre></td></tr></table></figure><p>由于<code>pacman</code>仓库中安装的<code>opencv</code>版本是最新的<code>opencv4</code>，我们需要修改<code>MediaPipe</code>中的配置文件来适配，修改<code>third_party/opencv_linux.BUILD</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Description:</span><br><span class="hljs-comment">#   OpenCV libraries for video/image processing on Linux</span><br><br>licenses([<span class="hljs-string">&quot;notice&quot;</span>])  <span class="hljs-comment"># BSD license</span><br><br>exports_files([<span class="hljs-string">&quot;LICENSE&quot;</span>])<br><br><span class="hljs-comment"># The following build rule assumes that OpenCV is installed by</span><br><span class="hljs-comment"># &#x27;apt-get install libopencv-core-dev libopencv-highgui-dev \&#x27;</span><br><span class="hljs-comment"># &#x27;                libopencv-calib3d-dev libopencv-features2d-dev \&#x27;</span><br><span class="hljs-comment"># &#x27;                libopencv-imgproc-dev libopencv-video-dev&#x27;</span><br><span class="hljs-comment"># on Debian Buster/Ubuntu 18.04.</span><br><span class="hljs-comment"># If you install OpenCV separately, please modify the build rule accordingly.</span><br>cc_library(<br>    name = <span class="hljs-string">&quot;opencv&quot;</span>,<br>    hdrs = glob([<br>        <span class="hljs-comment"># For OpenCV 4.x</span><br>        <span class="hljs-comment">#&quot;include/aarch64-linux-gnu/opencv4/opencv2/cvconfig.h&quot;,</span><br>        <span class="hljs-comment">#&quot;include/arm-linux-gnueabihf/opencv4/opencv2/cvconfig.h&quot;,</span><br>        <span class="hljs-comment">#&quot;include/x86_64-linux-gnu/opencv4/opencv2/cvconfig.h&quot;,</span><br>        <span class="hljs-comment"># 将下面这行取消注释</span><br>        <span class="hljs-string">&quot;include/opencv4/opencv2/**/*.h*&quot;</span>,<br>    ]),<br>    includes = [<br>        <span class="hljs-comment"># For OpenCV 4.x</span><br>        <span class="hljs-comment">#&quot;include/aarch64-linux-gnu/opencv4/&quot;,</span><br>        <span class="hljs-comment">#&quot;include/arm-linux-gnueabihf/opencv4/&quot;,</span><br>        <span class="hljs-comment">#&quot;include/x86_64-linux-gnu/opencv4/&quot;,</span><br>        <span class="hljs-comment"># 将下面这行取消注释</span><br>        <span class="hljs-string">&quot;include/opencv4/&quot;</span>,<br>    ],<br>    linkopts = [<br>        <span class="hljs-string">&quot;-l:libopencv_core.so&quot;</span>,<br>        <span class="hljs-string">&quot;-l:libopencv_calib3d.so&quot;</span>,<br>        <span class="hljs-string">&quot;-l:libopencv_features2d.so&quot;</span>,<br>        <span class="hljs-string">&quot;-l:libopencv_highgui.so&quot;</span>,<br>        <span class="hljs-string">&quot;-l:libopencv_imgcodecs.so&quot;</span>,<br>        <span class="hljs-string">&quot;-l:libopencv_imgproc.so&quot;</span>,<br>        <span class="hljs-string">&quot;-l:libopencv_video.so&quot;</span>,<br>        <span class="hljs-string">&quot;-l:libopencv_videoio.so&quot;</span>,<br>    ],<br>    visibility = [<span class="hljs-string">&quot;//visibility:public&quot;</span>],<br>)<br></code></pre></td></tr></table></figure><h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><p>跑一下实例中的<code>Hello, World</code>。</p><p>首先设置一个环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> GLOG_logtostderr=1</span><br></code></pre></td></tr></table></figure><p>然后一把梭哈：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">bazel run --define MEDIAPIPE_DISABLE_GPU=1 \<br>    mediapipe/examples/desktop/hello_world:hello_world<br></code></pre></td></tr></table></figure><p>在第一次编译的时候会下载大量的依赖文件，如果遇到网络错误可以多试几次，<del>我试了三次才完成</del>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell">Starting local Bazel server and connecting to it...<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;com_google_absl&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;com_google_benchmark&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;flatbuffers&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;pybind11_bazel&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;com_googlesource_code_re2&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;com_google_protobuf&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;com_google_googletest&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;com_github_gflags_gflags&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;zlib&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;rules_python&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;build_bazel_rules_apple&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;build_bazel_rules_swift&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;build_bazel_apple_support&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;xctestrunner&#x27; because it already exists.<br>DEBUG: /home/ricardo/.cache/bazel/_bazel_ricardo/9d4c3ea39592a9aa5075148d2a9caf3e/external/org_tensorflow/third_party/repo.bzl:132:14: <br>Warning: skipping import of repository &#x27;pybind11&#x27; because it already exists.<br>WARNING: /home/ricardo/Documents/code/cpp/mediapipe/mediapipe/framework/tool/BUILD:184:24: in cc_library rule //mediapipe/framework/tool:field_data_cc_proto: target &#x27;//mediapipe/framework/tool:field_data_cc_proto&#x27; depends on deprecated target &#x27;@com_google_protobuf//:cc_wkt_protos&#x27;: Only for backward compatibility. Do not use.<br>WARNING: /home/ricardo/Documents/code/cpp/mediapipe/mediapipe/framework/BUILD:54:24: in cc_library rule //mediapipe/framework:calculator_cc_proto: target &#x27;//mediapipe/framework:calculator_cc_proto&#x27; depends on deprecated target &#x27;@com_google_protobuf//:cc_wkt_protos&#x27;: Only for backward compatibility. Do not use.<br>INFO: Analyzed target //mediapipe/examples/desktop/hello_world:hello_world (84 packages loaded, 1747 targets configured).<br>INFO: Found 1 target...<br>Target //mediapipe/examples/desktop/hello_world:hello_world up-to-date:<br>  bazel-bin/mediapipe/examples/desktop/hello_world/hello_world<br>INFO: Elapsed time: 3.962s, Critical Path: 0.31s<br>INFO: 1 process: 1 internal.<br>INFO: Build completed successfully, 1 total action<br>INFO: Build completed successfully, 1 total action<br>I20230115 20:26:29.880736 47247 hello_world.cc:57] Hello World!<br>I20230115 20:26:29.880805 47247 hello_world.cc:57] Hello World!<br>I20230115 20:26:29.880817 47247 hello_world.cc:57] Hello World!<br>I20230115 20:26:29.880888 47247 hello_world.cc:57] Hello World!<br>I20230115 20:26:29.880957 47247 hello_world.cc:57] Hello World!<br>I20230115 20:26:29.881028 47247 hello_world.cc:57] Hello World!<br>I20230115 20:26:29.881096 47247 hello_world.cc:57] Hello World!<br>I20230115 20:26:29.881157 47247 hello_world.cc:57] Hello World!<br>I20230115 20:26:29.881198 47247 hello_world.cc:57] Hello World!<br>I20230115 20:26:29.881268 47247 hello_world.cc:57] Hello World!<br></code></pre></td></tr></table></figure><h3 id="编译Pose解决方案的Android-Archieve"><a href="#编译Pose解决方案的Android-Archieve" class="headerlink" title="编译Pose解决方案的Android Archieve"></a>编译Pose解决方案的Android Archieve</h3><p>我的需求有一个是在安卓手机上使用<code>MediaPipe</code>的<code>Pose</code>解决方案，需要编译出一个<code>AAR</code>安卓打包文件。</p><p>首先安装需要的依赖，<code>Android SDK</code>和<code>Android NDK</code>。这里使用<code>Android Studio</code>安装。</p><p>然后创建一个<code>bazel</code>编译的目标文件：在目录<code>mediapipe/examples/android/src/java/com/google/mediapipe/apps/</code>下创建一个文件夹<code>pose_tracking_aar</code>，在其中创建<code>BUILD</code>文件，写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">load(<span class="hljs-string">&quot;//mediapipe/java/com/google/mediapipe:mediapipe_aar.bzl&quot;</span>, <span class="hljs-string">&quot;mediapipe_aar&quot;</span>)<br><br>mediapipe_aar(<br>    name = <span class="hljs-string">&quot;mediapipe_pose_tracking&quot;</span>,<br>    calculators = [<span class="hljs-string">&quot;//mediapipe/graphs/pose_tracking:pose_tracking_gpu_deps&quot;</span>],<br>)<br></code></pre></td></tr></table></figure><p>使用命令编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">bazel build -c opt --strip=ALWAYS \<br>    --host_crosstool_top=@bazel_tools//tools/cpp:toolchain \<br>    --fat_apk_cpu=arm64-v8a,armeabi-v7a \<br>    --legacy_whole_archive=0 \<br>    --features=-legacy_whole_archive \<br>    --copt=-fvisibility=hidden \<br>    --copt=-ffunction-sections \<br>    --copt=-fdata-sections \<br>    --copt=-fstack-protector \<br>    --copt=-Oz \<br>    --copt=-fomit-frame-pointer \<br>    --copt=-DABSL_MIN_LOG_LEVEL=2 \<br>    --linkopt=-Wl,--gc-sections,--strip-all \<br>    //mediapipe/examples/android/src/java/com/google/mediapipe/apps/pose_tracking_aar:mediapipe_pose_tracking.aar<br></code></pre></td></tr></table></figure><p>如果在编译的过程中提示缺失<code>dx.jar</code>这个文件而且你用的SDK版本还是高于31的，那可能是SDK中缺失了这个文件，可以将SDk降级到30就含有这个文件了。我使用的解决办法比较离奇，我是将30版本的SDK文件中的这个文件软链接过来，解决了这个问题。</p><p><img src="/blog/compile-mediapipe/2023-01-15-22-05-41-Screenshot_20230115_220521.png"></p><p>编译消耗的时间可能比较的长，耐心等待即可。</p><p>为了在手机上使用，我们还需要编译出<code>binarypb</code>文件，从Google的服务器上下载<code>tflite</code>文件。</p><p>编译<code>binarypb</code>的过程比较的简单，编译目标在<code>mediapipe/graphs/pose_tracking</code>中，名称是<code>pose_tracking_gpu_binary_graph</code>，使用下列指令编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bazel build -c opt //mediapipe/graphs/pose_tracking:pose_tracking_gpu_binary_graph<br></code></pre></td></tr></table></figure><blockquote><p>在这里，Google默认添加了一个<code>input side packet</code>打开人体遮罩，如果不需要这个效果，需要删除<code>mediapipe/graphs/pose_tracking/pose_tracking_gpu.pbtxt</code>文件中的以下内容：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># Generates side packet to enable segmentation.</span><br><span class="hljs-keyword">node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  calculator</span>: <span class="hljs-string">&quot;ConstantSidePacketCalculator&quot;</span><br>  output_side_packet: <span class="hljs-string">&quot;PACKET:enable_segmentation&quot;</span><br>  node_options: &#123;<br>    [<span class="hljs-keyword">type</span>.googleapis.com/mediapipe.ConstantSidePacketCalculatorOptions]: &#123;<br>      packet &#123; bool_value: <span class="hljs-literal">true</span> &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>然后还需要从服务器上下载<code>tflite</code>文件，<code>Pose Tracking</code>这个解决方案需要两个<code>tflite</code>文件，第一个是<a href="https://storage.googleapis.com/mediapipe-assets/pose_detection.tflite">pose_detection.tflite</a>，第二个文件则有三个不同的选择，分别对于解决方案中提供的三个质量版本：</p><p><img src="/blog/compile-mediapipe/2023-01-19-20-20-40-Screenshot_20230119_202008.png"></p><p>下载地址是<a href="https://storage.googleapis.com/mediapipe-assets/pose_landmark_full.tflite">pose_landmark_full.tflite</a>，<a href="https://storage.googleapis.com/mediapipe-assets/pose_landmark_heavy.tflite">pose_landmark_heavy.tflite</a>和<a href="https://storage.googleapis.com/mediapipe-assets/pose_landmark_lite.tflite">pose_landmark_lite.tflite</a>。</p><blockquote><p>下面是原来使用<code>WSL</code>编译的过程。</p></blockquote><h2 id="编译环境概述-1"><a href="#编译环境概述-1" class="headerlink" title="编译环境概述"></a>编译环境概述</h2><p>我使用的基于WSL2的Ubuntu 22.04编译。主要是参考官方的<a href="https://google.github.io/mediapipe/getting_started/install.html#installing-on-debian-and-ubuntu">安装文档</a>。</p><h2 id="编译-2"><a href="#编译-2" class="headerlink" title="编译"></a>编译</h2><h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h3><p>首先安装两个基础性的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install build-essential git<br></code></pre></td></tr></table></figure><p>然后安装MediaPipe的编译管理工具<code>bazel</code>，这里我是通过<code>npm</code>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add -g @bazel/bazelisk<br></code></pre></td></tr></table></figure><p>通过运行<code>bazel version</code>验证安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ bazel version<br>Bazelisk version: v1.13.2<br>WARNING: Invoking Bazel <span class="hljs-keyword">in</span> batch mode since it is not invoked from within a workspace (below a directory having a WORKSPACE file).<br>Extracting Bazel installation...<br>Build label: 5.3.2<br>Build target: bazel-out/k8-opt/bin/src/main/java/com/google/devtools/build/lib/bazel/BazelServer_deploy.jar<br>Build time: Wed Oct 19 18:22:12 2022 (1666203732)<br>Build timestamp: 1666203732<br>Build timestamp as int: 1666203732<br></code></pre></td></tr></table></figure><p>安装<code>Miniconda</code>，再在环境中安装<code>numpy</code>。编译中依赖于<code>Python</code>和<code>numpy</code>，这里网上的资料汗牛充栋，我就不过多赘述。</p><p>在准备玩上面的环境之后，我们就可以用<code>git</code>将MediaPipe的源代码克隆下来了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/google/mediapipe.git<br></code></pre></td></tr></table></figure><h3 id="安装Opencv和FFmpeg"><a href="#安装Opencv和FFmpeg" class="headerlink" title="安装Opencv和FFmpeg"></a>安装Opencv和FFmpeg</h3><p>我这里选择的是手动编译安装opencv，安装的步骤参考官方的安装脚本，但是脚本中的不少内容已经过时。</p><p>首先安装必要的依赖库和编译管理工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install cmake ffmpeg libavformat-dev libdc1394-dev libgtk2.0-dev \<br>                       libjpeg-dev libpng-dev libswscale-dev libtbb2 libtbb-dev \<br>                       libtiff-dev<br></code></pre></td></tr></table></figure><blockquote><p>注意：官方脚本中要求安装<code>libdc1394-22-dev</code>这个包，但是按照这篇<a href="https://askubuntu.com/questions/1407580/unable-to-locate-package-libdc1394-22-dev">回答</a>，这个包已经被<code>libdc1392-dev</code>取代了。</p></blockquote><p>在临时文件夹中创建一个文件专门用来编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp<br>mkdir opencv<br><span class="hljs-built_in">cd</span> opencv/<br></code></pre></td></tr></table></figure><p>使用<code>git</code>下载Opencv的源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/opencv/opencv_contrib.git<br>git <span class="hljs-built_in">clone</span> https://github.com/opencv/opencv.git<br></code></pre></td></tr></table></figure><p>在仓库中签出到指定的版本分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> opencv<br>git checkout 3.4<br><span class="hljs-built_in">cd</span> ../opencv_contrib<br>git checkout 3.4<br></code></pre></td></tr></table></figure><p>创建编译文件，使用指定的<code>cmake</code>参数生成编译文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ../opencv<br>mkdir release<br><span class="hljs-built_in">cd</span> release<br>cmake .. -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_INSTALL_PREFIX=/usr/<span class="hljs-built_in">local</span> \<br>          -DBUILD_TESTS=OFF -DBUILD_PERF_TESTS=OFF -DBUILD_opencv_ts=OFF \<br>          -DOPENCV_EXTRA_MODULES_PATH=/tmp/opencv/opencv_contrib/modules \<br>          -DBUILD_opencv_aruco=OFF -DBUILD_opencv_bgsegm=OFF -DBUILD_opencv_bioinspired=OFF \<br>          -DBUILD_opencv_ccalib=OFF -DBUILD_opencv_datasets=OFF -DBUILD_opencv_dnn=OFF \<br>          -DBUILD_opencv_dnn_objdetect=OFF -DBUILD_opencv_dpm=OFF -DBUILD_opencv_face=OFF \<br>          -DBUILD_opencv_fuzzy=OFF -DBUILD_opencv_hfs=OFF -DBUILD_opencv_img_hash=OFF \<br>          -DBUILD_opencv_js=OFF -DBUILD_opencv_line_descriptor=OFF -DBUILD_opencv_phase_unwrapping=OFF \<br>          -DBUILD_opencv_plot=OFF -DBUILD_opencv_quality=OFF -DBUILD_opencv_reg=OFF \<br>          -DBUILD_opencv_rgbd=OFF -DBUILD_opencv_saliency=OFF -DBUILD_opencv_shape=OFF \<br>          -DBUILD_opencv_structured_light=OFF -DBUILD_opencv_surface_matching=OFF \<br>          -DBUILD_opencv_world=OFF -DBUILD_opencv_xobjdetect=OFF -DBUILD_opencv_xphoto=OFF \<br>          -DCV_ENABLE_INTRINSICS=ON -DWITH_EIGEN=ON -DWITH_PTHREADS=ON -DWITH_PTHREADS_PF=ON \<br>          -DWITH_JPEG=ON -DWITH_PNG=ON -DWITH_TIFF=ON<br></code></pre></td></tr></table></figure><blockquote><p>注意安装自己下载源代码的地址修改<code>-DOPENCV_EXTRA_MUDULES_PATH</code>的值</p></blockquote><blockquote><p>安装过程中还会下载一系列的依赖包，请注意自己的网络环境</p></blockquote><p>使用<code>make</code>指令进行编译和安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j 16<br>sudo make install<br></code></pre></td></tr></table></figure><p>编辑链接器的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo touch /etc/ld.so.conf.d/mp_opencv.conf<br>sudo bash -c  <span class="hljs-string">&quot;echo /usr/local/lib &gt;&gt; /etc/ld.so.conf.d/mp_opencv.conf&quot;</span><br>sudo ldconfig -v<br></code></pre></td></tr></table></figure><p>然后进行MediaPipe的目录，用脚本进行配置文件的修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./setup_opencv.sh config_only<br></code></pre></td></tr></table></figure><h2 id="运行首个例子："><a href="#运行首个例子：" class="headerlink" title="运行首个例子："></a>运行首个例子：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GLOG_logtostderr=1<br>bazel run --define MEDIAPIPE_DISABLE_GPU=1 mediapipe/examples/desktop/hello_world:hello_world<br></code></pre></td></tr></table></figure><p>在等待一段时间的下载依赖和编译之后，我们可以看见：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">I20221110 22:00:50.899885 14357 hello_world.cc:57] Hello World!<br>I20221110 22:00:50.899948 14357 hello_world.cc:57] Hello World!<br>I20221110 22:00:50.899955 14357 hello_world.cc:57] Hello World!<br>I20221110 22:00:50.899960 14357 hello_world.cc:57] Hello World!<br>I20221110 22:00:50.899962 14357 hello_world.cc:57] Hello World!<br>I20221110 22:00:50.899982 14357 hello_world.cc:57] Hello World!<br>I20221110 22:00:50.900000 14357 hello_world.cc:57] Hello World!<br>I20221110 22:00:50.900025 14357 hello_world.cc:57] Hello World!<br>I20221110 22:00:50.900030 14357 hello_world.cc:57] Hello World!<br>I20221110 22:00:50.900193 14357 hello_world.cc:57] Hello World!<br></code></pre></td></tr></table></figure><p>如果出现了各种奇怪的报错，那可以执行这条命令重新安装依赖再编译试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bazel clean --expunge<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>动作捕捉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用WSL设置CSAPP实验环境</title>
    <link href="/blog/2022/09/03/wsl-setup-csapp/"/>
    <url>/blog/2022/09/03/wsl-setup-csapp/</url>
    
    <content type="html"><![CDATA[<h1 id="利用WSL设置CSAPP实验环境"><a href="#利用WSL设置CSAPP实验环境" class="headerlink" title="利用WSL设置CSAPP实验环境"></a>利用WSL设置CSAPP实验环境</h1><p><code>CSAPP</code>这本书为自学的学生们提供了不少的<code>LAB</code>供大家在联系中提高，但是这些<code>LAB</code>的编写普遍需要一个<code>Linux</code>的实验环境，但是目前大多数人手中的环境都是<code>Windows</code>平台，没有办法原生的运行这些<code>LAB</code>。在以前的实践中，这个问题往往是通过安装虚拟机来解决的，但是现在我们有了更好的解决方案——<code>Windows Subsystem for Linux</code>，简称<code>WSL</code>。</p><span id="more"></span><h3 id="WSL简介"><a href="#WSL简介" class="headerlink" title="WSL简介"></a>WSL简介</h3><blockquote><p>WSL的<a href="https://docs.microsoft.com/zh-cn/windows/wsl">官方文档</a>，大部分的信息都可以在官方文档中找到</p></blockquote><p>WSL，官方中文翻译：适用于Linux的Windows子系统，“可以让开发人员直接在Windows上按原样运行GNU&#x2F;Linux环境，且不会产生传统虚拟机或者双启动设置开销”，简而言之，这就是Windows为广大开发人员提供的一项轻量化的Linux虚拟环境。</p><h3 id="WSL安装"><a href="#WSL安装" class="headerlink" title="WSL安装"></a>WSL安装</h3><blockquote><p>需要系统版本在Windows 10 2004以上</p></blockquote><p>按下<code>Ctrl+S</code>组合键打开Windows搜索界面，搜索<code>Powershell</code>，使用管理员权限运行这个应用程序，在打开的界面中输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl -<span class="hljs-literal">-install</span><br></code></pre></td></tr></table></figure><p>回车，等待所有的进度条都走完，重新启动系统。</p><p><img src="/blog/2022/09/03/wsl-setup-csapp/1.png" alt="设置的画面"></p><p>在重启完成之后，Ubuntu系统会自动启动并完成一系列的配置，在其中需要你为这个系统设置一个用户。输入这个用户的名称和密码即可。</p><blockquote><p>在终端中输入密码时，命令行中不会有任何显示</p><p>这个用户将成为此Linux系统的管理员</p><p>现在开始就得习惯命令行操作了</p></blockquote><p>在完成设置之后，我们就可以在任意的命令行界面（比如<code>cmd</code>, <code>powershell</code>）输入<code>wsl</code>来启动这个虚拟的Linux环境了。</p><h3 id="设置一个漂亮的终端界面"><a href="#设置一个漂亮的终端界面" class="headerlink" title="设置一个漂亮的终端界面"></a>设置一个漂亮的终端界面</h3><p>在上文中我们已经完成了WSL的安装和设置，但是作为我们将常常使用的界面，这些个黑框框莫名显得有点过于简陋。我们可以从<code>Microsoft Store</code>下载<code>Windows Terminal</code>这个应用来优化终端界面的显示，还有一系列的插件和<code>Shell</code>可供我们选择，由于这个部分和本文关系不大，这里就不赘述了。</p><h3 id="更换APT下载源"><a href="#更换APT下载源" class="headerlink" title="更换APT下载源"></a>更换APT下载源</h3><p>APT是Ubuntu系统中默认的软件包管理器，是一个很方便的软件下载安装更新卸载神器，不过唯一的问题是下载源在国外，我们需要切换为国内的镜像源。</p><p>清华的<a href="https://mirrors.tuna.tsinghua.edu.cn/">TUNA源</a>是比较推荐的，使用帮助<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">见此</a>。</p><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><p>测试换源是否成功。</p><p><img src="/blog/2022/09/03/wsl-setup-csapp/2.png" alt="证书错误"></p><p>如果在换源的过程中报错<code>Certificate verification failed</code>，可以将配置文件中的所有<code>https</code>更改为<code>http</code>来临时解决。</p><blockquote><p>我平时使用<a href="https://mirrors.bupt.edu.cn/">北邮镜像</a>，貌似没遇到这个问题。不过还是记录一下，<del>而且在校内速度拉满</del></p></blockquote><h3 id="下载CSAPP的LAB资料并使用编辑"><a href="#下载CSAPP的LAB资料并使用编辑" class="headerlink" title="下载CSAPP的LAB资料并使用编辑"></a>下载CSAPP的LAB资料并使用编辑</h3><p>这里介绍两种下载LAB进入<code>WSL</code>中的方法。</p><h4 id="直接使用命令从网络上下载"><a href="#直接使用命令从网络上下载" class="headerlink" title="直接使用命令从网络上下载"></a>直接使用命令从网络上下载</h4><p>打开你想要编写csapp的lab的位置，我这里是<code>~/Documents/Code/C/csapp</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Documents/Code/C/csapp<br></code></pre></td></tr></table></figure><p>使用下列命令从csapp的官方网站上下载lab资料</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget http://csapp.cs.cmu.edu/3e/datalab-handout.tar<br>--2022-09-03 16:57:26--  http://csapp.cs.cmu.edu/3e/datalab-handout.tar<br>Resolving csapp.cs.cmu.edu (csapp.cs.cmu.edu)... 128.2.100.230<br>Connecting to csapp.cs.cmu.edu (csapp.cs.cmu.edu)|128.2.100.230|:80... connected.<br>HTTP request sent, awaiting response... 200 OK<br>Length: 1075200 (1.0M) [application/x-tar]<br>Saving to: ‘datalab-handout.tar’<br><br>datalab-handout.tar                   100%[=======================================================================&gt;]   1.03M   103KB/s    <span class="hljs-keyword">in</span> 10s<br><br>2022-09-03 16:57:37 (101 KB/s) - ‘datalab-handout.tar’ saved [1075200/1075200]<br><br>$ ls<br>datalab-handout.tar<br></code></pre></td></tr></table></figure><p>在命令中的网址是在csapp的<a href="http://csapp.cs.cmu.edu/3e/labs.html">官方页面</a>中复制粘贴下来的</p><h4 id="先下载在Windows系统中在复制粘贴进入WSL"><a href="#先下载在Windows系统中在复制粘贴进入WSL" class="headerlink" title="先下载在Windows系统中在复制粘贴进入WSL"></a>先下载在Windows系统中在复制粘贴进入WSL</h4><blockquote><p>在WSL中Windows系统的硬盘均会被挂在到<code>/mnt</code>文件夹下，比如C盘就会被挂载到<code>/mnt/c</code>中</p><p>不过最好不要直接在WSL中使用Windows文件路径下的文件搞开发，这个访问是靠网络实现的，性能很弱。最好复制进入WSL中之后在进行开发操作</p></blockquote><p>先在Windows系统中使用浏览器将所有的lab下载到本地。</p><p>在WSL的命令行中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp /mnt/c/Users/ricardo/Downloads/datalab-handout.tar ~/Documents/Code/C/csapp<br></code></pre></td></tr></table></figure><p>命令的第一个路径是需要复制的文件在Windows系统中的路径，第二个是在WSL中的目标路径。</p><p>再将lab的数据压缩包下载到本地之后，使用以下的命令来解压压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xvf datalab-handout.tar<br></code></pre></td></tr></table></figure><p>来解压对应的压缩包</p><h3 id="编译运行第一个实验"><a href="#编译运行第一个实验" class="headerlink" title="编译运行第一个实验"></a>编译运行第一个实验</h3><blockquote><p>这里就以一个是作为例子来说明如何运行这些lab，其他的lab请仔细阅读压缩包中的README文件</p></blockquote><p>使用<code>make</code>指令编译在实验中需要使用到的二进制文件。首先安装会被使用的软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install gcc make<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make -v<br>GNU Make 4.2.1<br>Built <span class="hljs-keyword">for</span> x86_64-pc-linux-gnu<br>Copyright (C) 1988-2016 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br>$ gcc -v<br>Using built-in specs.<br>COLLECT_GCC=gcc<br>COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper<br>OFFLOAD_TARGET_NAMES=nvptx-none:hsa<br>OFFLOAD_TARGET_DEFAULT=1<br>Target: x86_64-linux-gnu<br>Configured with: ../src/configure -v --with-pkgversion=<span class="hljs-string">&#x27;Ubuntu 9.4.0-1ubuntu1~20.04.1&#x27;</span> --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-Av3uEd/gcc-9-9.4.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu<br>Thread model: posix<br>gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.1)<br></code></pre></td></tr></table></figure><p>确认需要使用的软件安装完成。</p><p>进入解压之后的文件夹，使用<code>make</code>指令编译需要用到的二进制文件</p><p>如果遇到报错，部分头文件未找到：</p><p><img src="/blog/2022/09/03/wsl-setup-csapp/3.png" alt="Error"></p><p>不要慌张，这是正常的。</p><p>使用下列命令来安装缺失的运行时库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install gcc-multilib<br></code></pre></td></tr></table></figure><p>在库安装完成之后，再使用<code>make</code>编译就没有问题了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make<br>gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c<br>btest.c: In <span class="hljs-keyword">function</span> ‘test_function’:<br>btest.c:332:23: warning: ‘arg_test_range[1]’ may be used uninitialized <span class="hljs-keyword">in</span> this <span class="hljs-keyword">function</span> [-Wmaybe-uninitialized]<br>  332 |     <span class="hljs-keyword">if</span> (arg_test_range[1] &lt; 1)<br>      |         ~~~~~~~~~~~~~~^~~<br>gcc -O -Wall -m32 -o fshow fshow.c<br>gcc -O -Wall -m32 -o ishow ishow.c<br></code></pre></td></tr></table></figure><p>按照README文件中的说明，使用<code>btest</code>程序测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./btest<br>Score   Rating  Errors  Function<br>ERROR: Test bitXor(-2147483648[0x80000000],-2147483648[0x80000000]) failed...<br>...Gives 2[0x2]. Should be 0[0x0]<br>ERROR: Test tmin() failed...<br>...Gives 2[0x2]. Should be -2147483648[0x80000000]<br>ERROR: Test isTmax(-2147483648[0x80000000]) failed...<br>...Gives 2[0x2]. Should be 0[0x0]<br>ERROR: Test allOddBits(-2147483648[0x80000000]) failed...<br>...Gives 2[0x2]. Should be 0[0x0]<br>ERROR: Test negate(-2147483648[0x80000000]) failed...<br>...Gives 2[0x2]. Should be -2147483648[0x80000000]<br>ERROR: Test isAsciiDigit(-2147483648[0x80000000]) failed...<br>...Gives 2[0x2]. Should be 0[0x0]<br>ERROR: Test conditional(-2147483648[0x80000000],-2147483648[0x80000000],-2147483648[0x80000000]) failed...<br>...Gives 2[0x2]. Should be -2147483648[0x80000000]<br>ERROR: Test isLessOrEqual(-2147483648[0x80000000],-2147483648[0x80000000]) failed...<br>...Gives 2[0x2]. Should be 1[0x1]<br>ERROR: Test logicalNeg(-2147483648[0x80000000]) failed...<br>...Gives 2[0x2]. Should be 0[0x0]<br>ERROR: Test howManyBits(-2147483648[0x80000000]) failed...<br>...Gives 0[0x0]. Should be 32[0x20]<br>ERROR: Test floatScale2(0[0x0]) failed...<br>...Gives 2[0x2]. Should be 0[0x0]<br>ERROR: Test floatFloat2Int(0[0x0]) failed...<br>...Gives 2[0x2]. Should be 0[0x0]<br>ERROR: Test floatPower2(0[0x0]) failed...<br>...Gives 2[0x2]. Should be 1065353216[0x3f800000]<br>Total points: 0/36<br></code></pre></td></tr></table></figure><p>测试运行完成，开始<del>痛苦的</del>快乐的学习吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年暑假碎碎念</title>
    <link href="/blog/2022/08/22/2022-summer-vacation/"/>
    <url>/blog/2022/08/22/2022-summer-vacation/</url>
    
    <content type="html"><![CDATA[<h1 id="2022年暑假总结"><a href="#2022年暑假总结" class="headerlink" title="2022年暑假总结"></a>2022年暑假总结</h1><p>在8个月的漫长寒假的最后两个月，<del>也就是俗称的暑假中</del>，我都干了些什么？</p><span id="more"></span><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><ul><li>七天速通<code>C++</code>和<code>Qt</code>，搞定了上个学期的计算导论大作业，再用七天的时间整理代码和<del>瞎编</del>撰写文档，希望能得到一个不错的分数，挽救我那岌岌可危的平均分。</li><li>开始阅读<code>CSAPP</code>，<del>也就是传说中的没人理解计算机系统</del>，但说实话，阅读的进度真的聊胜于无，我用了整整一个月才读完第二章，做完对应的Lab，甚至Lab中的少数题连网上的题解都不咋看得懂，开始怀疑自己是不是真的适合学习这个学科。目前希望在假期的最后四天里面能够创造奇迹，拆弹成功，<del>指完成第三章的<code>Bomb Lab</code></del>。</li></ul><blockquote><p>学习日记：</p><p>7月1日：刷B站</p><p>7月2日：刷B站</p><p>7月3日：刷B站，刷到了其他程序员分享自己学习经历的视频，深感焦虑，决定明天开始好好学习，重新做人</p><p>7月4日：刷B站</p><blockquote><p>此处致敬了胡适之先生的日记，特此说明</p></blockquote></blockquote><ul><li>开始学习伯克利的<code>cs61b</code>，虽然在假期的后半段才开始学习。</li><li>更新了三篇博客。分别记录了我在学习<code>Qt</code>中的一点小收获，我在小组合作中的一点思考和我对未来主力语言选择的迷茫。</li><li>下定决定要参加下一学期的物理竞赛，但是在听了讲座之后直接决定开学再开始学习，<del>我知道我在家没法学习，俗称开摆</del></li><li>又捡起了<code>Blender</code>，并在<a href="https://github.com/tanjian1998/bupt_minecraft">Github</a>上找到了伟大的前辈们在<code>Minecraft</code>里复刻的老校区，希望能用<code>Blender</code>渲染几张图当作桌面。</li></ul><p><img src="/blog/2022/08/22/2022-summer-vacation/result1.png" alt="唯一的一张成品"></p><blockquote><p>在此感谢所有为此付出过汗水的前辈们，让我这个即将搬入老校区的萌新能提前一睹老校区的风采。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>继续完善我的<a href="https://github.com/jackfiled/post_calendar_android">邮历</a>，虽然目前开发由于一些技术之外的原因暂停了。</li><li>花了半个月的时间学习<code>Go</code>的API开发，给<a href="https://squidward.top/">通知大全</a>的后端做了一点<a href="https://gitee.com/zoctopus/ddlgo-back/pulls/2">小更改</a></li></ul><blockquote><p><code>Go</code>设计的挺好的，就是有点差。</p></blockquote><ul><li>写了一个从教务系统自动获得课表和生成<code>ICS</code>日历文件的<a href="https://github.com/jackfiled/JWGLService">微服务</a>，合并到上面提到的后端中。</li><li>做了<code>LeetCode</code>上的第一题。</li></ul><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><ul><li><p>买了文明六，但是一分钟都没玩</p></li><li><p>每日原神清委托，抽到了宵宫。</p></li><li><p>入坑崩崩崩，但是已经领了两次回归奖励了。终于推到了第十二章。</p></li></ul><blockquote><p>在第九章一睹传说中“最后一课”的风采。</p></blockquote><blockquote><p>也许我可以把我的Steam账号租出去了，买了二十几个游戏，总游戏时长还不超过200个小时，目前一共就<code>战地五</code> 和<code>CS:GO</code>这两个游戏我玩上了50个小时。</p></blockquote><h3 id="番剧"><a href="#番剧" class="headerlink" title="番剧"></a>番剧</h3><p>这个假期看完了：</p><ul><li>路人女主的养成方法</li><li>徒然喜欢你</li><li>中二病也要谈恋爱</li><li>女武神的餐桌</li></ul><blockquote><p>邪王真眼是最强的</p></blockquote><p>现在正在看：</p><ul><li>终将成为你</li></ul><blockquote><p>首先我不是白河豚，其次我不是白河豚，最后我不是白河豚。</p></blockquote><h3 id="目前手上还没填上的坑"><a href="#目前手上还没填上的坑" class="headerlink" title="目前手上还没填上的坑"></a>目前手上还没填上的坑</h3><ul><li>修改我博客的主题。由于现在我用的主题在2017年之后就不在更新，bug啥的已经不少了，也缺少了一些我想要的功能，打算在原本的基础上小修小补。</li><li>把我的树莓派改造好。在我的期望中，这个玩意儿应该是一台全自动的BT做种机，寝室里的影音中心，再加上我的Arduino单片机，应该还可以自动检测寝室的温湿度和控制空调的启动。</li><li>假期入了<a href="https://space.bilibili.com/20259914">稚晖君</a>的<a href="https://www.bilibili.com/video/BV1VA411p7MD">Holo Cubic</a>，花了我大几百块钱，但是买回来之后就一直处在吃灰的状态，希望这个学期能有时间来折腾一下这个玩意儿。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>决定退出融媒体中心的综合影视部。</li><li>和前女友和平分手，希望她能在南京好好的生活。</li><li>终于参加了一次原魔群线上<del>高峰论坛</del>面基，见了见久违的高中同学们。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>.net从入门到放弃再到入门</title>
    <link href="/blog/2022/08/21/dotnet-come-to-go/"/>
    <url>/blog/2022/08/21/dotnet-come-to-go/</url>
    
    <content type="html"><![CDATA[<h1 id="net从入门到放弃再到入门"><a href="#net从入门到放弃再到入门" class="headerlink" title=".net从入门到放弃再到入门"></a>.net从入门到放弃再到入门</h1><p>我宣布下面的内容都是我在胡扯。在写了一学期的<code>Java</code>和<code>Springboot</code>之后，我的评价是<code>Java</code>是什么垃圾东西，<code>C#</code>才是永远的神！</p><p><del>这是一篇专业的.net劝退指南，详细记述了我为啥选择了.net又为啥选择了放弃。</del></p><span id="more"></span><h3 id="开端——WPF桌面应用"><a href="#开端——WPF桌面应用" class="headerlink" title="开端——WPF桌面应用"></a>开端——WPF桌面应用</h3><p><del>在今年年初的时候，受到<a href="https://squidward.top/">通知大全</a>启发，我决定编写一款自己的DDL管理应用程序。在一开始，我打算先在Windows平台上编写，当时我了解到Windows上最正统的桌面应用程序开发方式就是采用微软自家的.net平台开发，同时在<a href="https://zhihu.com/">知乎</a>上一群人在吹<code>C#</code>在设计上是如何如何的优于<code>JAVA</code>，当然在这里没有说他们的观点错误的意思，把我忽悠的一愣一愣的。.net在当时已经有了比较老旧的<code>WinForms</code>框架、比较流行的<code>WPF</code>框架和最新的<code>MAUI</code>框架。</del>秉持着中国人中庸的思想潮流<del>，我选择了<code>WPF</code>图形框架作为我当时开发的框架，从此入了.net平台的坑。</del></p><blockquote><p>如今这个桌面端的项目已经基本烂尾，项目开源在<a href="https://github.com/jackfiled/PostCalendarWindows">github</a>，算是警醒后来的我在技术选型时应该更加的慎重</p></blockquote><p><del>说实话，在开发的一开始，我就感觉力不从心。</del></p><p><del>第一，官方文档好但不完全好。微软虽然提供了本地化过的文档，但是有很大比例都是机翻的文档。我觉得吧，放机翻的文档还不如直接放英文原文的文档。同时，文档的大部分都是API列表一类的参考资料，对于初学者来说比较重要的“实用教程”等等部分内容较少，虽然文档全面而详细，但对于初学者来说并没有很大的帮助。毕竟我们不知道在数以万计的API中，哪个才能实现自己的需求。</del></p><p><del>第二，国内缺少.net相关的社区氛围。这点也是最为劝退的地方，相比于<code>JAVA</code>在国内广泛的应用和丰富的社区内容，国内.net和<code>C#</code>相关的内容除了在<code>Unity</code>游戏开发中还算广泛，其他称得上是乏善可陈。</del></p><p><del>在一堆好几年前的博客和半懂不懂的英文文档中沉浮一个月之后，我总算是写出了一个可以运行的成品。随着新学期的到来，以学业繁忙为借口，我停止了这个应用的开发。</del></p><h3 id="重启——服务器开发"><a href="#重启——服务器开发" class="headerlink" title="重启——服务器开发"></a>重启——服务器开发</h3><p><del>在经历了桌面应用的失败之后，我转移了自己的开发重心，开始了移动应用的开发，这次我没有坚持被微软的<code>MAUI</code>那八字还没有一撇的技术忽悠进去，选择了<code>flutter</code>框架搞开发。有应用自然就得有提供数据的后端，在开发服务器时，我又被微软的<code>ASP.NET</code>给“忽悠”了进去。</del></p><p><del>平心而论，<code>ASP.NET</code>开发的过程比上文中的桌面应用程序的开发还是要顺利不少。毕竟现在采用<code>B/S</code>架构的服务更多，个人感觉国内应用这项技术的人也不少，相关的技术资料也就不少，我入门的过程也就流畅许多。</del></p><p><del>虽然但是，在开发的过程中劝退的地方也不少。第一是微软自己的版本更迭，尤其是在微软宣布<code>dotnet core</code>，将.net开源之后，个人感觉国内的开发者似乎不是很感冒，还是用着原来的老一套。第二是和现在的技术流行方向不同，原本采用<code>JAVA</code>搞服务器的开发不太可能再更换语言，第二新入行的开发者也会选择当下流行的<code>GO</code>等语言，这就导致在开发中有一种单打独斗的感觉，很难找到人同你合作。</del></p><h3 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h3><p><del>在坚持学习.net八个月之后，我还是决定放弃，转向学习<code>JAVA</code>。</del></p><ul><li><del>没人用的技术的技术不要硬刚，即使是好技术也不要。没人用的技术就像一潭死水，只有流动起来，才能孕育生机和活力，否则只能在原地腐烂。</del></li><li><del>之于我而言，语言不仅仅是开发软件的工具，更是需要计算机相关知识的工具。转向<code>JAVA</code>的原因之一就是我目前学习的数据结合课——伯克利的<code>CS61b</code>就是采用<code>JAVA</code>作为编程语言的。</del></li></ul><p><del>虽然我已经决定将我的主力语言转向<code>JAVA</code>，</del>但不得不承认<code>C#</code>在语言上的特性还是很不错的，以后我的重心不会放在<code>C#</code>上，但是他也不会从的技能树上消失。也许在若干年之后，我的主力语言又变回<code>C#</code>了（笑）。</p><blockquote><p>全文的最后一句话可能是我现在唯一认同的了</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
      <tag>dotnet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生代码大作业初体验</title>
    <link href="/blog/2022/07/27/big-homework/"/>
    <url>/blog/2022/07/27/big-homework/</url>
    
    <content type="html"><![CDATA[<h1 id="代码大作业初体验"><a href="#代码大作业初体验" class="headerlink" title="代码大作业初体验"></a>代码大作业初体验</h1><p>在大学也呆了一年了，终于遇上了第一个需要多人合作的写代码项目。从四月底分组完成，任务部署下来到七月初接近尾声，在这两个多月的时间里，也算是经历了不少，学到了不少。</p><span id="more"></span><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>项目的主体是一个公交车的自动调度系统。公交车行驶在一个环形的轨道上，站点均匀的分布于其上；系统需要支持在每个站点上创建顺时针上车、逆时针上车和下车三种请求，并调度公交车按照一定的策略前往这些站点处理请求。</p><blockquote><p>在一开始我还以为这个策略需要自己优化，通过比较不同组之间调度完成请求需要的时间来决定优劣，想着还有点可怕，后来明确策略的规则是由老师指定。</p><p>不过要是真的按照策略的优化来比较程序之间的优劣，想想还是很有趣的一件事情，不过用在一个计算机专业第一节专业课的大作业上显得就有点那啥了。</p></blockquote><p>项目要求使用C语言实现一个控制台中的核心版，再采用 <code>C/C++</code>相关的图形化框架实现一个动画版。</p><p>整个小组由三个人组成。剩下的两个人有 <code>Dev C++</code>的经历，对于C语言的语法还算是比较熟悉。</p><h2 id="项目的管理"><a href="#项目的管理" class="headerlink" title="项目的管理"></a>项目的管理</h2><h3 id="构建管理工具"><a href="#构建管理工具" class="headerlink" title="构建管理工具"></a>构建管理工具</h3><p>在开始一个项目之前，应该先选择一个合适的技术栈。在选择的时候，不能光考虑自己平时的习惯和技术的先进性，还得考虑组内所有人的合作效率，不能让代码就在你一个人的电脑上能跑起来，同时这个技术得是所有人都比较熟悉的，不能说你在那里吭哧吭哧的都把代码写完了，其他人还搁那看文档和教程。</p><p>在 <code>C</code>语言项目的管理上，我首先排除了一个文件打天下的“传统”生产模式。这个方案的优点是所有人的十分熟悉，不需要任何额外的技术，也对 <code>C</code>语言的IDE没有任何的要求，不管你是用初学者的常用的 <code>Dev C++</code>，还是宇宙第一IDE <code>Visual Studio</code>，都可以打开这个单独的文件然后编译运行。但是，这个方案也就这一个优点了。且不论手工合并很多人撰写代码的复杂繁琐，光是一个长达1000行的文件就看得人头疼欲裂了。</p><p>其次我排除了 <code>Visual Studio</code>，虽然VS也算是一个开箱即用的开发平台。第一，我自己对 <code>Visual Studio</code>不熟悉，如果在合作开发中遇到了一些VS的问题，我可能也不知道该如何解决。第二，我们验收使用的OJ平台采用的是 <code>GCC</code>编译器，不同于 <code>MSVC</code>编译器，虽然编译器行为不同的情况很少遇见，但为了避免这些一遇到就是纯玄学的问题，我还是采用 <code>MinGW64 GCC</code>编译器，这个编译器也算是我常用的编译器。</p><p>最后我选择了利用 <code>cmake</code>组织项目，<code>MinGW64 GCC</code>作为编译器的方案。虽然 <code>cmake</code>还是一个比较新的玩意儿，但是只要编译的模板在一开始写好了，就基本上不用再修改了，并不需要所有人都熟悉 <code>cmake</code>。其次，<code>cmake</code>对于IDE没有依赖，几乎所有的主流 <code>C/C++ </code>IDE都支持利用  <code>cmake </code>管理 <code>C/C++</code>项目。我这次的推荐IDE是 <code>VSCode </code>，如果使用 <code>cmake</code>进行项目的管理，只需要安装一个插件就可以进行开发了，避免了很多麻烦的问题。</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>本次开发中老师提供了 <code>gitlab</code>作为代码托管平台，因此在开发过程中我们顺理成章的采用 <code>Git</code>作为版本管理的工具，<del>虽然组里的同学完全不会。</del></p><p>为了避免对于 <code>Git</code>的学习占用了过多的开发时间，我没有在项目开始之前花费大量的时间指导他们学习 <code>Git</code>，而是再讲解了基本的 <code>Git</code>操作流程，比如 <code>commit push pull</code>之后就直接开始项目的开发，让大家在开发项目的过程中逐渐熟悉这个工具的使用，在工作中遇到问题再解决对应的问题。同时为了避免合并冲突等比较复杂的情景在早期出现，在最开始开发的时候我让大家都在不同的文件上工作，在后期必须要在同一文件上工作时再来解决合并的问题。</p><blockquote><p>我一直以为，在开发的过程中学习才是进步最快的方式</p></blockquote><p>而且采用 <code>Git</code>还有一个好处，采用 <code>Github</code>的 <code>Insight</code>功能可以轻松的看出大家的贡献值（）。</p><p><img src="/blog/2022/07/27/big-homework/1.png" alt="img" title="贡献"></p><h2 id="一些技术上的收获"><a href="#一些技术上的收获" class="headerlink" title="一些技术上的收获"></a>一些技术上的收获</h2><h3 id="面向对象永远的神"><a href="#面向对象永远的神" class="headerlink" title="面向对象永远的神"></a>面向对象永远的神</h3><p>在这次的开发过程中，核心版要求完全使用C语言进行开发，而在动画版中则可以采用C++进行开发。在编写动画版的代码时，我没有简单的重用核心版的代码，而是利用面向对象的方法完全重写了一遍，虽然重写耗费了我不少的时间，但是在重写了之后，程序中不再使用全局变量；控制公交车通过抽象为三个虚函数，不同的策略对这三个虚函数进行不同的实现来达到不同的调度效果，这样核心的控制流只用编写一遍，个人认为优于核心版中几种策略的控制流虽然大体相似但是在细节上均有不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得当前公交车应该前进的方向</span><br><span class="hljs-comment">     * @return 公交车前进的方向</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetBusDirection</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得公交车在当前指定的策略下应该处理的请求</span><br><span class="hljs-comment">     * @return 请求指针</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bus_query_t</span> *<span class="hljs-title">GetTargetQuery</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取公交车现在可以顺便处理的请求</span><br><span class="hljs-comment">     * @return 请求指针</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bus_query_t</span> *<span class="hljs-title">HandleBTWQuery</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br></code></pre></td></tr></table></figure><blockquote><p>然而我还是没有对象</p></blockquote><h3 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h3><p>具体参见<a href="https://rrricardo.top/blog/2022/07/01/qt-learning/#more">初学Qt的一点小笔记</a>，<code>QProperyAnimation</code>那个的多重继承是真的惊艳到我了，感觉在 <code>C++</code>这样复杂又精妙的语言面前我还有很多可以学习的地方。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>在这次的开发过程中我引入了 <code>Google Test</code>单元测试框架以进行单元测试，虽然并不是所有的模块都编写了对应的测试集，但是单元测试的引入真的帮助我们在开发初期解决的很多的小问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST</span>(rail, CreateRails)<br>&#123;<br>    <span class="hljs-keyword">rail_node_t</span> *head = <span class="hljs-built_in">CreateRails</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">rail_node_t</span> *p = head;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">EXPECT_EQ</span>(p-&gt;id, i);<br>        <span class="hljs-built_in">EXPECT_EQ</span>(p-&gt;next_node_distance, <span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">EXPECT_EQ</span>(p-&gt;last_node_distance, <span class="hljs-number">10</span>);<br>        p = p-&gt;next_node;<br>    &#125;<br><br>    p = head-&gt;last_node;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>; i &gt;= <span class="hljs-number">1</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">EXPECT_EQ</span>(p-&gt;id, i);<br>        <span class="hljs-built_in">EXPECT_EQ</span>(p-&gt;next_node_distance, <span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">EXPECT_EQ</span>(p-&gt;last_node_distance, <span class="hljs-number">10</span>);<br>        p = p-&gt;last_node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>在开发的过程中总有一些重复性的简单工作，这时 <code>Python</code>这些脚本语言的妙处就展示出来了。由于核心版是采用线上的OJ平台进行测试，在提交的时候代码为单文件，于是我编写了一个<a href="https://github.com/jackfiled/auto_bus/blob/master/main.py">脚本</a>来帮助我完成这个工作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初学Qt的一点小笔记</title>
    <link href="/blog/2022/07/01/qt-learning/"/>
    <url>/blog/2022/07/01/qt-learning/</url>
    
    <content type="html"><![CDATA[<h1 id="初学Qt的一点小笔记"><a href="#初学Qt的一点小笔记" class="headerlink" title="初学Qt的一点小笔记"></a>初学Qt的一点小笔记</h1><p>最近的大作业需要用 <code>C/C++</code>的技术栈实现一个图形化界面，<code>Qt</code>作为C++图形化框架久负盛名，正好借着这个写大作业的机会学习一下这个应用广泛的框架。</p><span id="more"></span><h2 id="Qt的安装"><a href="#Qt的安装" class="headerlink" title="Qt的安装"></a>Qt的安装</h2><p>现在比较新版本的Qt貌似都不支持下载离线安装包了，受制于网络环境，在线安装的体验并不是很好。为了比较顺利的完成安装，使用老套路——国内镜像。清华大学就提供了Qt在线安装的镜像，具体的使用说明参照镜像的这篇<a href="https://mirrors.tuna.tsinghua.edu.cn/help/qt/">帮助</a>，在下载之前记得注册一个Qt的账号。</p><h3 id="版本的选择"><a href="#版本的选择" class="headerlink" title="版本的选择"></a>版本的选择</h3><p>现在<code>Qt</code>最新的版本已经来到了<code>Qt6</code>，虽然现在<code>Qt5</code>仍然十分的流行，网上大部分的资料与教程都是采用<code>Qt5</code>写成的，我最后还是选选择了<code>Qt6</code>，理由主要有以下三点：</p><ul><li>工程并不是很复杂，而且开发的周期很长，即使在中间遇到了一些新版本的玄学问题，我也有比较充足的时间来解决或者避开问题</li><li><code>Qt6</code>开始完全转向<code>cmake</code>管理项目，而我的这个大作业“恰好”就是采用<code>cmake</code>管理的</li><li><code>Qt6</code>是新版本，以后开发的时间还很长，稳定的开发环境还不是我现在需要的，学习的人还是应该积极的跟踪新技术（当然只是我自己的想法）</li></ul><h3 id="编译器的选择"><a href="#编译器的选择" class="headerlink" title="编译器的选择"></a>编译器的选择</h3><p>我在<code>Windows</code>平台上进行开发，虽然在之前学习过程中<code>MinGW64 GCC</code>是我更常用的编译器，但是他毕竟是一个移植的编译器，而不是“官方”的编译器，我选择了<code>MSVC</code>作为这次项目的编译器。</p><blockquote><p>这里还有一个理由是我正在大力推进<code>WSL</code>在我日常开发中的使用，我正在把我所有的<code>C/C++</code>项目都迁移到<code>WSL</code>中进行开发，在<code>Windows</code>中我已经不保留<code>MinGW64</code>编译器了。</p></blockquote><h3 id="预处理的使用"><a href="#预处理的使用" class="headerlink" title="预处理的使用"></a>预处理的使用</h3><p>在这次<code>Qt</code>开发中我用到了两个预处理器——<code>moc</code>和<code>uic</code>，前者服务于<code>Qt</code>的元对象系统(Meta Object System)，后者负责与将<code>Qt Designer</code>生成了<code>*.ui</code>文件转换为编译器可以编译的<code>ui_*.h</code>文件。这里重点说说前者，<code>Qt</code>的元对象系统是<code>Qt</code>信号和槽机制的基础，所有需要用到信号槽的类都需要继承<code>QObject</code>这个基类，同时在类里申明<code>Q_OBJECT</code>这个宏，而且，这个头文件还得被<code>moc</code>预处理器预处理为<code>moc_*.cpp</code>之后才能被编译器所编译，否则就会报<code>LNK2001</code>连接错误，提示有三个函数无法找到定义，</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@errorMsg</span>.<span class="hljs-attribute">obj </span>: error <span class="hljs-attribute">LNK2001</span>: unresolved external symbol <span class="hljs-string">&quot;public: virtual struct QMetaObject const * __thiscall errorMsg::metaObject(void)const &quot;</span> (?metaObject<span class="hljs-variable">@errorMsg</span><span class="hljs-variable">@@UBEPBUQMetaObject</span><span class="hljs-variable">@@XZ</span>)<br><br>errorMsg.<span class="hljs-attribute">obj </span>: error <span class="hljs-attribute">LNK2001</span>: unresolved external symbol <span class="hljs-string">&quot;public: virtual void * __thiscall errorMsg::qt_metacast(char const *)&quot;</span> (?qt_metacast<span class="hljs-variable">@errorMsg</span><span class="hljs-variable">@@UAEPAXPBD</span><span class="hljs-variable">@Z</span>)<br><br>errorMsg.<span class="hljs-attribute">obj </span>: error <span class="hljs-attribute">LNK2001</span>: unresolved external symbol <span class="hljs-string">&quot;public: virtual int __thiscall errorMsg::qt_metacall(enum QMetaObject::Call,int,void * *)&quot;</span> (?qt_metacall<span class="hljs-variable">@errorMsg</span><span class="hljs-variable">@@UAEHW4Call</span><span class="hljs-variable">@QMetaObject</span><span class="hljs-variable">@@HPAPAX</span><span class="hljs-variable">@Z</span>)@<br></code></pre></td></tr></table></figure><p>在我这次的工程中，需要以下设置才能让<code>moc</code>预处理器正确工作：</p><ul><li>在<code>CMakeLists.txt</code>文件中需要定义<code>set(CMAKE_AUTOMOC ON)</code></li><li>在包含这个头文件的地方需要将头文件的名称改为预处理之后的名称<code>moc_*.cpp</code>，如下图所示</li></ul><p><img src="/blog/2022/07/01/qt-learning/1.png"></p><h2 id="Qt-Designer"><a href="#Qt-Designer" class="headerlink" title="Qt Designer"></a>Qt Designer</h2><p>在一开始我对于这个软件的使用是比较迷茫的，没有搞明白哪些内容是在<code>Designer</code>中完成的，哪些内容是在代码中完成的，在代码中是如何访问控件的。</p><blockquote><p>这里需要说明的是，我是用<code>CLion</code>作为IDE开发<code>C/C++</code>项目，在这里<code>Qt Designer</code>是作为外部工具存在的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">MainWindow::<span class="hljs-built_in">MainWindow</span>(QWidget *parent) : <span class="hljs-built_in">QMainWindow</span>(parent)<br>&#123;<br>    ui = <span class="hljs-keyword">new</span> Ui::MainWindow;<br>    ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那个名叫<code>Ui</code>的命名空间让我迷茫了一阵子，在那个空间中也有一个和当前创建的UI类名字相同的类，我以为这是单例模式之类的高级设计模式，在研读了几篇博客，查看了<code>UIC</code>处理器生成的头文件之后，我才意识到这是两个处在不同命名空间但名字相同的类，在<code>Ui</code>命名空间中的那个类就是<code>*.ui</code>文件中定义了那个界面，可以通过这个指针来访问我们在<code>Qt Designer</code>中定义的那些控件。</p><h2 id="Qt-Property-Animation"><a href="#Qt-Property-Animation" class="headerlink" title="Qt Property Animation"></a>Qt Property Animation</h2><p><code>QPropertyAnimation</code>是<code>Qt</code>自己实现的一个简单实用的动画框架，在这次开发中，我使用这个框架实现了对<code>QGraphicsItem</code>这个对象的动画。这里主要的问题是，<code>QGraphicsItem</code>这个类并没有继承<code>QObject</code>，然而<code>QPropertyAnimation</code>这个动画框架所作用的对象必须是一个继承自<code>QObject</code>的对象，而且需要实现动画的属性必须注册<code>Q_PROPERTY</code>，根据文档的说明，我定义了这样的一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusItem</span>:</span> <span class="hljs-keyword">public</span> QObject, <span class="hljs-keyword">public</span> QGraphicsPixmapItem<br>&#123;<br>    <span class="hljs-function">Q_OBJECT</span><br><span class="hljs-function">    <span class="hljs-title">Q_PROPERTY</span><span class="hljs-params">(QPointF pos READ pos WRITE setPos)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span>:</span><br><span class="hljs-function">    explicit BusItem(const QPixmap&amp; pixmap);</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这个类多重继承了<code>QObject</code>和<code>QGraphicsPixmapItem</code>，这样既可以被<code>QPropertyAnimation</code>所作用，也可以像正常的<code>QGraphicsItem</code>一样被添加进<code>QGrphicsScene</code>并设置各种属性。</p><p>而<code>Q_PROPERTY</code>这个宏给<code>Qt</code>的类型系统注册了一个类型为<code>QPointF</code>名叫<code>pos</code>的变量，这个变量的读通过调用<code>pos()</code>函数来实现，这个变量的写通过调用<code>setPos()</code>函数来实现，这个变量也就是我需要设计动画的变量。</p><blockquote><p>这句代码给我的感觉像是在C#中的<code>set</code>和<code>get</code>两个访问器。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学生用啥配置——计算机专业</title>
    <link href="/blog/2022/06/13/laptop-for-computer/"/>
    <url>/blog/2022/06/13/laptop-for-computer/</url>
    
    <content type="html"><![CDATA[<h1 id="大学生用啥配置——计算机专业"><a href="#大学生用啥配置——计算机专业" class="headerlink" title="大学生用啥配置——计算机专业"></a>大学生用啥配置——计算机专业</h1><blockquote><p>本文是应B站UP主<a href="https://space.bilibili.com/35359510">远古时代装机猿</a>发起的<a href="https://www.bilibili.com/video/BV1kZ4y1i7Le">大学生用啥配置</a>公益活动而写</p><p>目前某不知名211大学计算机专业在读</p><p>同时也是给我的许多即将选择计算机专业的同学做一个参考</p></blockquote><span id="more"></span><h2 id="专业需求"><a href="#专业需求" class="headerlink" title="专业需求"></a>专业需求</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>对于大学生来说，还是一台<code>Windows</code>系统的电脑更加的适合，理由如下：</p><ul><li>在学校中的大多人都是使用<code>Windows</code>系统，老师的教学设计也是以同学们拥有一台<code>Windows</code>系统的电脑为基础的，如果你在学习过程中遇到了一些<code>MacOS</code>系统所特有的问题，可能连可以问的人都没有。</li><li>在学习过程中可能会遇到一些课程需要使用只有<code>Windows</code>版本的软件，如果你购买了一台苹果电脑，遇上这种时候就只能使用学校提供的机房或者是安装虚拟机了。</li></ul><h3 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h3><p>目前我经常使用的软件如下所示：</p><ul><li><a href="https://code.visualstudio.com/">VSCode</a>微软出品的文本编辑器，是我目前使用最多的软件之一。我用它来写简单的<code>C/C++</code>,<code>Python</code>和<code>latex</code>等。</li><li><a href="https://visualstudio.microsoft.com/zh-hans/vs/">Visual Studio</a><del>宇宙第一IDE</del>用来写<code>C#</code>。</li><li><a href="https://www.jetbrains.com/pycharm/">PyCharm</a>用来写比较复杂的<code>Python</code>项目。</li><li><a href="https://www.jetbrains.com/clion/">CLion</a>用来写大型的<code>C/C++</code>项目。</li><li><a href="https://www.jetbrains.com/webstorm/">WebStorm</a>用来写网页。</li><li><a href="https://developer.android.google.cn/studio/">Android Studio</a>用来开发安卓应用。</li><li><a href="https://docs.microsoft.com/zh-cn/windows/wsl/about">WSL</a>在<code>Windows</code>系统上使用<code>Linux</code>的神器，其实质上就是一个虚拟机，不过需要的性能少于传统的虚拟机。</li></ul><p>还有一系列日常软件像<code>QQ</code>啥的就不列出了，但凡是台电脑也不至于运行不起来。</p><blockquote><p>严格来说，我还是有相当多的“常用”软件没有提及，像C语言编译器<code>MinGW GCC</code>这类的工具，不过这类命令行工具对性能的需求不容易体现出来，就在下文中对应的IDE处提及了。</p></blockquote><h3 id="日常使用场景的列举"><a href="#日常使用场景的列举" class="headerlink" title="日常使用场景的列举"></a>日常使用场景的列举</h3><blockquote><p>列举了一些专业学习中常见的一些使用场景，记录了对应性能占用，使文章显得有理有据（确信）</p><p>可直接跳转到分析部分</p></blockquote><h4 id="学习、编写C-C-程序"><a href="#学习、编写C-C-程序" class="headerlink" title="学习、编写C/C++程序"></a>学习、编写<code>C/C++</code>程序</h4><p>打开<code>WSL </code>,<code>VSCode</code>和一大堆的网页。</p><p>目前的性能占用如图所示</p><p><img src="/blog/2022/06/13/laptop-for-computer/c.png"></p><p>在编译代码时CPU占用会有一个短时的提升，不过由于目前编写的程序都较为简单，编译转瞬就完成了。</p><h4 id="编写较为复杂的C-C-项目"><a href="#编写较为复杂的C-C-项目" class="headerlink" title="编写较为复杂的C/C++项目"></a>编写较为复杂的<code>C/C++</code>项目</h4><p>以我目前的C语言大作业为例，打开两个<code>CLion</code>进行开发，同时打开一大堆网页查资料。</p><p>性能的占用如图所示</p><p><img src="/blog/2022/06/13/laptop-for-computer/clion.png"></p><p>在刚打开项目和编译整个项目时CPU的占用会上升，但在完成之后，CPU的占用就会回落。</p><p>目前项目的代码量在50000+，编译整个项目需要15秒左右，但是大部分的代码都是引用的库，只需要编译一次，后续的修改只用编译2~3秒就可以。 </p><h4 id="编写C-项目"><a href="#编写C-项目" class="headerlink" title="编写C#项目"></a>编写<code>C#</code>项目</h4><p>通过安装了<code>Reshaper</code>插件的<code>Visual Studio</code>打开<code>WPF</code>应用进行开发，同时也是打开一大堆浏览器标签页查资料。</p><p>性能占用如图所示</p><p><img src="/blog/2022/06/13/laptop-for-computer/csharp.png"></p><h4 id="写网站"><a href="#写网站" class="headerlink" title="写网站"></a>写网站</h4><p>打开<code>WebStorm</code>编写网站。</p><p>性能占用如图所示：</p><p><img src="/blog/2022/06/13/laptop-for-computer/web.png"></p><h3 id="软件的运行需求分析"><a href="#软件的运行需求分析" class="headerlink" title="软件的运行需求分析"></a>软件的运行需求分析</h3><p>目前我常用的软件以吃CPU和内存为主，对于显卡的需求相对来说不大。</p><p>CPU的占用主要出现在打开项目和编译项目上，不同CPU的差别主要体现在需要的时间上，对于实际的使用不能产生比较的区别，<del>编译的时间长一点还可以去摸鱼</del>。</p><p>而对于内存的需求就比较大了，目前一般的IDE(集成开发环境)一打开就会吃掉1G以上的内存，项目越复杂还可能更大，而且在写代码的同时还会打开一大堆的浏览器标签页查看资料和文档，众所都周知，目前流行的<code>chrome</code>浏览器内核在使用内存上是一点都不吝啬，因此推荐16G起步。</p><p>对于显卡，如果不需要在工作之余进行一些手脑协调训练，那么亮机卡或者核显就是不错的选择，对于写代码的人来说，高U低显才是合适的搭配。</p><p>之于硬盘，写代码对于硬盘的占用也不算是太大，代码文件基本上都是文本文件，不会占用太多的空间。占用比较大的IDE也一般都在10G以下，<del>比起一些学习资料小很多了</del>一般512G的固态硬盘就完全足够了。 </p><p>之于屏幕，作为大多数的学习活动都在电脑上进行的专业，把钱花在一块素质良好的屏幕上是完全值得的。与游戏电竞不同的是，在选择屏幕是应该更看重分辨率而不是刷新率，刷新率在60Hz就完全足够了，如果是笔记本较低的刷新率还有助于降低耗电量，增加续航。</p><h2 id="我用啥配置"><a href="#我用啥配置" class="headerlink" title="我用啥配置"></a>我用啥配置</h2><p>作为一名眼脑协调训练热爱者的我，目前手持的笔记本自然是一台正宗的游戏本——Dell G15 5511，这台笔记本的详细配置如下所示：</p><ul><li>i7-11800H</li><li>16G DDR4 3200</li><li>RTX3060(125W)</li><li>512G SSD + 1T SSD（自行添加）</li><li>1080P 165Hz 屏幕</li></ul><p>下面简单谈谈对于我而言，这台电脑的优势和劣势：</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>强大的性能使我的游戏体验还是十分不错的</li><li>有一个硬盘位可以自行扩展以存放学习资料</li><li>内存不是板载，在后期内存成为瓶颈时可以扩展</li><li>拥有数量众多的接口</li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>离电续航较短，在某次考试中由于没有占到有插座的座位而不得不使用核显+60Hz+低亮度来完成2个小时的考试。</li><li>旅行重量比较大，官方标称重量2.81千克，再加上一块板砖充电器，带着它出门的体验一言难尽，简直是锻炼身体的必备利器。</li><li>风扇的噪音比较大，在图书馆里使用可能给你带来一些尴尬。</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote><p>如果我是今年毕业，我一定选台式机+轻薄本的组合，去年硬件市场的行情打消了我这个蓄谋已久的想法</p></blockquote><p>我目前的打算自己再攒一台锐龙6000系轻薄本出来用，否则随着后面专业课程的增加，需要用到笔记本的场景只会越来越多，如果仍然像现在一样几乎限制在寝室里使用，难以为继。毕竟众所都周知啊，寝室并不是一个理想的学习环境，如果想要沉浸式的学习，还是得去图书馆和教室。</p><h2 id="给后来者的建议"><a href="#给后来者的建议" class="headerlink" title="给后来者的建议"></a>给后来者的建议</h2><ul><li>如果你不玩游戏，那么一台性能释放较好的核显轻薄本就是你最好的选择。短时间强大的性能释放足够帮你应付编译等场景下的性能需求，轻薄本不错的续航和较轻的重量又能保证你在学校中能够相对自由的移动</li><li>如果你玩游戏，那么还是顺从自己的内心使用游戏本吧！否则你看见同寝室友愉快玩耍时，也会生出再买一台电脑的念头。</li><li>如果你不确定或者有点小钱，也可以选择轻薄本加台式机的组合，这也是最让人感到舒适的配置组合，兼具轻薄本的灵活性和台式机的高性能，唯一的缺点是贵，不过那算是我的缺点</li><li>内存保底16G，如果能更大当然更好</li><li>屏幕素质可以选择的高一些</li><li>如果你已经确定自己要选购一台台式机，请确保自己未来就读的学校有足够的空间和供电来确保自己可以愉快的玩耍，否则不要买了轻薄本到了学校傻了眼，“这小破地方怎么放台式机啊”，或者是游戏一开全寝断电</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c-include-problems</title>
    <link href="/blog/2022/05/08/c-include-problems/"/>
    <url>/blog/2022/05/08/c-include-problems/</url>
    
    <content type="html"><![CDATA[<h1 id="C项目中有关头文件的一些问题"><a href="#C项目中有关头文件的一些问题" class="headerlink" title="C项目中有关头文件的一些问题"></a>C项目中有关头文件的一些问题</h1><p>最近在完成一门<code>C</code>语言课程的大作业，课设老师要求我们将程序分模块的开发。在编写项目头文件的时候，遇到了一些令本菜鸡大开眼界的问题。</p><span id="more"></span><h2 id="头文件相互包含问题"><a href="#头文件相互包含问题" class="headerlink" title="头文件相互包含问题"></a>头文件相互包含问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我项目的结构大致如图所示：</p><p><img src="/blog/2022/05/08/c-include-problems/1.png"></p><p>在<code>include</code>的头文件目录下有两个头文件，<code>rail.h</code>和<code>bus.h</code>，这两个头文件分别定义了两个结构体<code>rail_node_t</code>和<code>bus_t</code>。</p><p>但在这两个结构题的定义中，我互相使用了指向对方结构体的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*rail.h的内容*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;bus.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ...<br>    <br>    <span class="hljs-keyword">bus_t</span> *bus;<br>    ...<br>&#125; rail_node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rail_node</span> <span class="hljs-title">rail_node_t</span>;</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*bus.h的内容*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;rail.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ...<br>    <br>    <span class="hljs-keyword">rail_node_t</span>* rail_node_pos;<br><br>...<br>&#125; bus;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus</span> <span class="hljs-title">bus_t</span>;</span><br></code></pre></td></tr></table></figure><p>于是在编译的时候，编译器就会报<code>rail_node_t</code>和<code>bus_t</code>这两个结构体未定义的错误。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>这个问题解决起来也非常的容易，只要修改其中一个结构体的定义就可以了。在以后的设计中注意不要出现这类相互包含的结构体。</p><blockquote><p>而且一般这种时候虽然IDE的静态检查不会报错，但是自动补全却会失效。所以当你发现你的IDE出现一些奇怪行为的时候，就要格外小心了。</p></blockquote><h2 id="自己定义的头文件和内部头文件命名冲突的问题"><a href="#自己定义的头文件和内部头文件命名冲突的问题" class="headerlink" title="自己定义的头文件和内部头文件命名冲突的问题"></a>自己定义的头文件和内部头文件命名冲突的问题</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>在项目中我引入了谷歌的单元测试框架<a href="https://github.com/google/googletest">GTest</a>。但是在编译测试程序的时候遇到了一些困难。</p><p>项目的<code>test</code>文件夹下是单元测试文件夹，但是在编译的时候会报错</p><p><img src="/blog/2022/05/08/c-include-problems/2.png"></p><p>大意就是在一个google test内部的头文件中有几个函数找不到定义，这个函数都位于<code>io.h</code>这个头文件中。</p><p>在一开始我以为是平台的兼容性问题，但是在我电脑的其他项目中引用这个库都没有问题。在一开始我以为是google test作为一个为<code>C++</code>设计的单元测试库在我的<code>C</code>项目中出现了不兼容的情况，于是我在设计一个假的单元测试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gtest/gtest.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gmock/gmock.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> ::testing::Return;<br><span class="hljs-keyword">using</span> ::testing::AtLeast;<br><span class="hljs-keyword">using</span> ::testing::Exactly;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> testing;<br><br><span class="hljs-built_in">TEST</span>(test, test)<br>&#123;<br>    <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>不测试任何我编写的库，而只是验证单元测试框架是否能正确运行。但是这个单元测试仍然无法通过编译，报错和之前的一样。</p><p>于是我便打开了编译中出错的<code>gtest-port.h</code>文件，发现在预处理的过程中头文件的替换出现了问题：在我自己的头文件中也有一个名叫<code>io.h</code>的头文件，负责项目中的输入输出，而在预处理的过程中预处理器用这个头文件代替了标准库中的<code>io.h</code>,但在我自己的头文件中自然没有测试库需要的函数了。</p><blockquote><p>在找bug的过程中还有比较玄学的事情，如果我把我库里的头文件一个个的添加，就可以编译成功，但是如果在第一次编译成功之后再次<code>cmake ..</code>，重新生成编译文件，再编译就失败了。这个玄学现象让我迷惑了很久。</p></blockquote><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>重新命名模块即可。在后续的模块设计中注意命名。</p><blockquote><p>这里还有一个小插曲，不要轻易相信IDE提供的重构功能。在这里<code>CLion</code>这个IDE就在我重命名头文件的时候把<code>gtest-port.h</code>中对<code>io.h</code>的引用也重构了。真是智能！<del>此处应有流汗黄豆</del></p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>只有在实际的开发中才能学到这些教训啊！</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅地使用学校VPN</title>
    <link href="/blog/2022/04/14/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%AD%A6%E6%A0%A1VPN/"/>
    <url>/blog/2022/04/14/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%AD%A6%E6%A0%A1VPN/</url>
    
    <content type="html"><![CDATA[<h1 id="优雅地使用学校VPN"><a href="#优雅地使用学校VPN" class="headerlink" title="优雅地使用学校VPN"></a>优雅地使用学校VPN</h1><span id="more"></span><h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>我所在的学校使用的是Global Protect提供的入校VPN，但是Global Protect的VPN客户端会劫持掉电脑上所有的网络连接，显然这并不是我们想要的，频繁开关VPN客户端的方法又有点愚蠢，在折腾了一会儿之后我发现了一条不错的思路。在docker的容器中采用openconnect连接学校VPN，再在容器中搭建一个socks5服务器，在本地使用Chrome浏览器使用这个socks5服务器就可以直接访问学校VPN了。而且，在docker Hub上已经有一个刚好符合我们需求的镜像——<a href="https://hub.docker.com/r/wazum/openconnect-proxy">openconnect-proxy</a>。</p><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><p>在本地或者服务器上拉取这个镜像，<del>安装docker的方式在本文中暂且不表</del>，采用docker-compose的方式部署你的容器。新建一个文件夹，在里面放置<code>docker-compose.yml</code>和<code>.env</code>文件，前者是docker的配置文件，后者是在docker中使用openconnect的配置文件。</p><p>docker-compose.yml的内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">vpn:</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">openconnect_vpn</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wazum/openconnect-proxy:latest</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">env_file:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">.env</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8888</span><span class="hljs-string">:8888</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8889</span><span class="hljs-string">:8889</span><br>    <span class="hljs-attr">cap_add:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">NET_ADMIN</span><br></code></pre></td></tr></table></figure><p>.env文件的内容如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">OPENCONNECT_URL=<span class="hljs-regexp">//</span>你的服务器地址<br>OPENCONNECT_USER=<span class="hljs-regexp">//</span>你的账号<br>OPENCONNECT_PASSWORD=<span class="hljs-regexp">//</span>你的密码<br>OPENCONNECT_OPTIONS=--protocol=<span class="hljs-regexp">//</span>你的服务器采用的协议，gp代表Global Protect<br></code></pre></td></tr></table></figure><p>然后运行镜像就完事了，如果在服务器上运行记得在安全组开启相应的端口</p><h2 id="详细的折腾探索过程"><a href="#详细的折腾探索过程" class="headerlink" title="详细的折腾探索过程"></a>详细的<del>折腾</del>探索过程</h2><h3 id="找到合适的VPN客户端"><a href="#找到合适的VPN客户端" class="headerlink" title="找到合适的VPN客户端"></a>找到合适的VPN客户端</h3><p>为了避免学校提供的VPN客户端会劫持所有的网络流量这个问题，首先得找到一个可以替代掉这个客户端的连接程序。</p><p>很快我就找到了也支持Global Protect协议的开源客户端，<a href="https://www.infradead.org/openconnect/">OpenConnect</a>。但是在简单的查阅文档之后，发现这个客户端也是会代理全局的网络流量。这条道路失败。</p><h3 id="尝试扩展这个开源的客户端"><a href="#尝试扩展这个开源的客户端" class="headerlink" title="尝试扩展这个开源的客户端"></a>尝试扩展这个开源的客户端</h3><p>既然这个连接客户端式开源的，那便有着无限的可能。而且不可能只有我一个人遇到了这个问题，一定有伟大的前人解决了这个问题。在各种博客文章中反复穿梭之后，我发现了一个<code>OpenConnect</code>的扩展插件，<a href="https://github.com/cernekee/ocproxy">ocproxy</a>，这个扩展可以建立一个Socks代理服务器，使OpenConnect只能处理发送给这个代理服务器网络流量。</p><p>大胜利~</p><h3 id="开始愉快的使用"><a href="#开始愉快的使用" class="headerlink" title="开始愉快的使用"></a>开始愉快的使用</h3><p>啪的一声，很快啊，这个服务器就在服务器上搭建起来了，就可以使用Chrome浏览器的Switch-Omega之类的插件使用这台服务器了。</p><p>还没有高兴到五分钟，在使用中我就发现这个服务貌似有点性能比较垃圾啊啊啊啊啊。</p><p>打开学校的通知门户，几乎就没有图片可以正常的打开，打开一些学校里的服务网站，稍微大一点的js文件直接无法加载。在反反复复的研究ocproxy那少得可怜的文档之后，我直接放弃了这个办法，这个玩意儿可以用，但不是完全可以用。</p><p>大失败再次降临力！</p><h3 id="上邪法——docker"><a href="#上邪法——docker" class="headerlink" title="上邪法——docker"></a>上邪法——docker</h3><blockquote><p>这已经不是一般的问题，必须出重拳。</p></blockquote><p>既然这些客户端会代理电脑上所有的网络流量，那我就找一台计算机专门让它代理！</p><p>但显然这里的计算机不是物理意义上的计算机，而是一台轻量化的应用运行平台，我在这里选择了docker。</p><p>在<a href="https://hub.docker.com/">docker-hub</a>上逛了逛，果然早有人意识到这个问题，在上面已经有了一个准备好的dockers镜像，<a href="https://hub.docker.com/r/wazum/openconnect-proxy">openconnect-proxy</a>。</p><p>很快的pull下镜像，一波建立容器运行，一个新的代理服务器又建立了起来。</p><p>大胜利~</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这个服务器在访问我们的教务系统时还是出问题了。。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建立博客过程的记录</title>
    <link href="/blog/2022/04/08/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <url>/blog/2022/04/08/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="建立博客过程的记录"><a href="#建立博客过程的记录" class="headerlink" title="建立博客过程的记录"></a>建立博客过程的记录</h1><h2 id="博客之始"><a href="#博客之始" class="headerlink" title="博客之始"></a>博客之始</h2><p>当我已经在Python的浩瀚大海遨（zheng）游（zha）了半个暑假后，我决定尝试一下传说中程序员专用的学(zhuang)习(bi)手(fangfa)段(fa)——建立自己的个人博客。作为一个半懂不懂的Python程序员，心中冒出的第一个想法自然是采用Python的Django作为开发自己的个人博客的手段。然而，在阅读了<a href="https://www.dusaiphoto.com/article/2/">用Django搭建个人博客</a>等的其他人搭建这类动态博客的过程记录之后，我便义无反顾的转向了采用javascript开发的博客框架<a href="https://hexo.io/">Hexo</a>，<del>说好的Python信仰呢</del>。无他，唯简单尔。</p><span id="more"></span><h2 id="安装需要的程序"><a href="#安装需要的程序" class="headerlink" title="安装需要的程序"></a>安装需要的程序</h2><h3 id="安装javascipt的运行环境"><a href="#安装javascipt的运行环境" class="headerlink" title="安装javascipt的运行环境"></a>安装javascipt的运行环境</h3><p>Hexo作为一个基于javasrcipt的博客框架，第一步自然是安装运行Javascript的环境。</p><p>Node.js就是几个基于Chrome V8引擎的Javascript运行时环境。这是一个异步事件驱动的Javascript运行时环境。同时Node还带有一个和<code>pip</code>功能类似的包管理工具<code>npm</code>,使我们可以方便的安装其他人开发的功能扩展包。我们就使用这种方便的方式安装<code>hexo</code>。</p><p>访问<a href="https://nodejs.org/en/">node.js官方网站</a>下载了node.js的14.17.4 LTS版本的安装包，下载完成后安装。在Powershell中输入</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br></code></pre></td></tr></table></figure><p>若能显示出node的版本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">v14</span>.<span class="hljs-number">17</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>便说明node.js安装成功。<br>再输入</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> -v<br></code></pre></td></tr></table></figure><p>显示出npm的版本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7</span>.<span class="hljs-number">20</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>便说明npm也安装完成。</p><blockquote><p>这里要特别说明，npm的更新快于node，可能在不久之后npm的版本就不是7.20.3了</p><p>同时可以使用<code>npm install -g npm</code>方便的升级npm</p></blockquote><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在Power shell中输入</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><blockquote><p>这里的-g代表global，即为全局安装Hexo，如果像我一样初次使用npm建议安装所有的包时都加上-g。</p></blockquote><p>npm的默认安装源在国外，如果在安装过程中遇到网络问题，可以像我们使用其他的包管理器一样换为国内源进行安装。在国内比较出名的npm镜像源是由部分淘宝程序员维护的淘宝源。</p><blockquote><p>2022年，淘宝源的域名由<a href="https://npm.taobao.org更改为https//npmmirror.com%E3%80%82">https://npm.taobao.org更改为https://npmmirror.com。</a></p></blockquote><h4 id="临时使用淘宝源作为下载方式"><a href="#临时使用淘宝源作为下载方式" class="headerlink" title="临时使用淘宝源作为下载方式"></a>临时使用淘宝源作为下载方式</h4><p>在利用npm安装npm包时，使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm --registry https:<span class="hljs-regexp">//</span>registry.npmmirror.com install <br></code></pre></td></tr></table></figure><p>可以在本次下载包时采用淘宝源作为下载地址。</p><h4 id="将下载地址设置为淘宝源"><a href="#将下载地址设置为淘宝源" class="headerlink" title="将下载地址设置为淘宝源"></a>将下载地址设置为淘宝源</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry  https:<span class="hljs-comment">//registry.npmmirror.com</span><br></code></pre></td></tr></table></figure><p>这样设置以后，每次下载包时都会从淘宝的服务器下载。</p><h4 id="使用cnpm下载"><a href="#使用cnpm下载" class="headerlink" title="使用cnpm下载"></a>使用cnpm下载</h4><p>cnpm是国内一些热心于开源的程序眼开发的一个node包，作用和node.js自带的npm完全一样，不过默认使用淘宝源下载。在下载cnpm之后就可以方便的在国内源和国外源之间切换，当使用国内源时使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cnpm install <br></code></pre></td></tr></table></figure><p>使用国外源时使用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> <br></code></pre></td></tr></table></figure><p>这就避免了在需要使用国外源时来回切换的麻烦。<del>虽然我应该不会用到国外源</del></p><p>开始时使用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> cnpm -g<br></code></pre></td></tr></table></figure><p>安装cnpm<br>然后使用</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">cnpm install Hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><p>安装Hexo博客框架。<br>再输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo -v</span><br></code></pre></td></tr></table></figure><p>验证安装是否完成。</p><p>我这里的输出是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hexo</span>-cli: <span class="hljs-number">4</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">os</span>: win<span class="hljs-number">32</span> <span class="hljs-number">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">19043</span><br><span class="hljs-attribute">node</span>: <span class="hljs-number">14</span>.<span class="hljs-number">17</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">v8</span>: <span class="hljs-number">8.4.371.23</span>-node.<span class="hljs-number">76</span><br><span class="hljs-attribute">uv</span>: <span class="hljs-number">1</span>.<span class="hljs-number">41</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">zlib</span>: <span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">11</span><br><span class="hljs-attribute">brotli</span>: <span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">ares</span>: <span class="hljs-number">1</span>.<span class="hljs-number">17</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">modules</span>: <span class="hljs-number">83</span><br><span class="hljs-attribute">nghttp2</span>: <span class="hljs-number">1</span>.<span class="hljs-number">42</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">napi</span>: <span class="hljs-number">8</span><br><span class="hljs-attribute">llhttp</span>: <span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">openssl</span>: <span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>k<br><span class="hljs-attribute">cldr</span>: <span class="hljs-number">39</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">icu</span>: <span class="hljs-number">69</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">tz</span>: <span class="hljs-number">2021</span>a<br><span class="hljs-attribute">unicode</span>: <span class="hljs-number">13</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="初次使用Hexo"><a href="#初次使用Hexo" class="headerlink" title="初次使用Hexo"></a>初次使用Hexo</h2><h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><p>进入一个我们准备用来设置博客的文件夹，在终端中输入</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Hexo <span class="hljs-keyword">init</span> blog<br></code></pre></td></tr></table></figure><p>Hexo会以blog为名称创建一个博客文件夹，这个文件夹的内容为</p><p><img src="/blog/2022/04/08/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AE%B0%E5%BD%95/1.png" alt="文件夹截图"></p><p><code>node_modules</code>文件夹是Hexo需要用到的一些npm依赖包的存放地址，<code>public</code>文件夹下是由Hexo渲染产生的静态博客文件，<code>scaffolds</code>文件夹是博客用到的模板文件，在默认情况下应该有<code>draft.md</code>,<code>page.md</code>,<code>post.md</code>三个模板文件。<code>themes</code>是Hexo中可以使用的主题文件。主题也是Hexo一个非常方便的设计，我们可以方便使用其他人编写的Hexo Themes，让自己的博客在不同的风格之间变换。<code>source</code>文件夹就是存放我们写作的博客的地方。一般这里面会有两个子文件夹，<code>_draft</code>, <code>_posts</code>。我们在里面在创建一个<code>img</code>文件夹，把自己的头像图片和网站的图标文件都放在里面，在之后的设置的时候使用。</p><p>在终端中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ hexo server<br>INFO  Validating config<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>会在本地运行Hexo自带的一台静态博客服务器。我们用浏览器访问<a href="http://localhost:4000/">http://localhost:4000</a>, 就可以看见Hexo博客的初始界面</p><p><img src="/blog/2022/04/08/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AE%B0%E5%BD%95/2.png" alt="初始截图"></p><p>这便说明安装成功了，<del>可以开香槟了</del></p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>在终端中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>我已经在设置中设置，不指定模板是自动生成草稿。具体设置见下一节。</p></blockquote><p>然后就会在前面提到的<code>_draft</code>文件夹下创建一个markdown文件和一个同名的资源文件夹，在资源文件夹下放置在文章中会用到的图片。接下来使用一款适合自己的markdown编辑器就可以开始文章的写作了。</p><blockquote><p>我使用的markdown编辑器是<a href="https://typora.io/">Typora</a>,但是这个软件在更新到正式版之后就开始收费了，不过我们可以在<a href="https://typora.io/releases/all">这里</a>找到版本小于1.0.0的beta版本使用。</p></blockquote><p>为了方便的在写作时插入图片，我下载安装了<code>hexo-asset-image</code>这个Hexo插件，但是由于这个插件总是在我的电脑上犯病，我自己做了一点修改，放在了<a href="https://github.com/jackfiled/hexo-asset-image">我的github上</a>。</p><p>通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install git+https://github.com/jackfiled/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>来安装我修改之后的包。</p><p>这样在typora中写作的时候，先通过格式-图像-设置图片根目录为hexo自动生成的资源文件夹，在需要插入图片时通过</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">example</span>](<span class="hljs-link">example.png</span>)<br></code></pre></td></tr></table></figure><p>这种方式来插入图片，其中<code>example.png</code>图片在资源文件夹下。这样在typora中可以正确显示，在hexo渲染出来的网页中也可以正确的显示。</p><p>在完成写作之后，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo publish <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><p>将文章发布，把markdown文件和资源文件夹从<code>_draft</code>文件夹移动到<code>_post</code>文件夹。</p><p>这时使用</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>就可以看见我们完成的博客文章了。</p><h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>为了选择一个恰当而合适的主题，以期避免可能引起的一些不必要的误会和不便，我们设立一个跨部门的多方委员会，用以充分考虑各方的意见，同时选择专门的专家主持流程严谨的研究，充分考虑科学界的意见。通过多次多方的协调会议，在完全理解各方需求的之后，委员会提供了多种选择以供我们选择。</p><blockquote><p>汉弗莱附身了属于是</p></blockquote><p>简而言之，我看了几个博客，下载了几个主题测试，然后选择了<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus">yilia-plus</a>。我比较看重的这个主题的原因是他比较简洁。</p><p>在blog文件夹中的themes文件夹<code>git clone</code>我们选择好的主题，在blog文件夹下的<code>_config.yaml</code>中设置主题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">yilia-plus</span><br></code></pre></td></tr></table></figure><p>然后我们在运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><p>就可以看见我们的主题设置已经生效。</p><h3 id="调整设置文件"><a href="#调整设置文件" class="headerlink" title="调整设置文件"></a>调整设置文件</h3><p>Hexo在一般情况下有两个配置文件我们会经常用到，blog根目录下的<code>_config.yaml</code>, 我们下载的主题文件夹下的<code>_config.yaml</code></p><h4 id="Hexo的设置"><a href="#Hexo的设置" class="headerlink" title="Hexo的设置"></a>Hexo的设置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Ricardo的博客</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;奇奇怪怪东西的聚居地&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Ricardo</span> <span class="hljs-string">Ren</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>第一部分的网站设置部分，根据自己的需求修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://rrricardo.top/blog</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></code></pre></td></tr></table></figure><p>第二部分，在url的地方填写自己的博客的地址。</p><p>第三部分<code>Directory</code>中我没有修改任何玩意儿。</p><p>第四部分<code>Writing</code>中我把默认使用的模板设置为草稿, 再将<code>post_asset_folder</code>设置为true,这样在使用<code>hexo new </code>命令使就会再md文件所在的目录创建一个同名的资源文件夹，把我们文章中会使用到的图片放在里面。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">default_layout:</span> <span class="hljs-string">draft</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>剩下的大部分我们就可以不用修改了。</p><h4 id="yilia-plus的设置"><a href="#yilia-plus的设置" class="headerlink" title="yilia-plus的设置"></a>yilia-plus的设置</h4><blockquote><p>由于这个主题是国人开发的，配置文件都有详细的中文注释，按着注释走就完事儿了。</p></blockquote><h2 id="将博客部署到云服务器"><a href="#将博客部署到云服务器" class="headerlink" title="将博客部署到云服务器"></a>将博客部署到云服务器</h2><h3 id="设置deploy"><a href="#设置deploy" class="headerlink" title="设置deploy"></a>设置deploy</h3><p>Hexo做为一个静态的博客框架，可以将整个博客网站直接渲染为静态页面,我们可以执行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><p>Hexo就会在<code>public</code>文件夹下生成整个博客的静态界面，我们只用在服务器上放置这些文件就可以了。</p><p>这里使用hexo提供的deploy功能来简化本地同步到git仓库的过程。</p><p>在终端执行下列命令，安装git部署插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>在根目录下的<code>_config.yaml</code>中设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@gitee.com:ricardo-ren/blog-deploy.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br>  <span class="hljs-attr">message:</span> <span class="hljs-string">Site</span> <span class="hljs-string">Update</span> &#123;&#123;<span class="hljs-string">now(&#x27;YYYY-MM-DD</span> <span class="hljs-string">HH:mm:ss&#x27;)</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>设置中的message信息可以按自己的喜好设置。</p><blockquote><p>如果使用这种方式记得先在git上创建远程仓库</p></blockquote><p>设置完成后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure><p>可能会提示没有设置用户名和邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> .deploy_git<br>git config ...<br></code></pre></td></tr></table></figure><p>这里进入的<code>.deploy_git</code>实际上就是git仓库在本地的位置。</p><h3 id="服务器clone"><a href="#服务器clone" class="headerlink" title="服务器clone"></a>服务器clone</h3><p>在服务器上适当的位置执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@gitee.com:ricardo-ren/blog-deploy.git<br></code></pre></td></tr></table></figure><p>这里将作为博客网站的根目录。</p><h3 id="nginx设置"><a href="#nginx设置" class="headerlink" title="nginx设置"></a>nginx设置</h3><p>在云服务器上我使用nginx作为反向代理服务器。由于nginx也是一个不错的静态资源服务器，hexo博客也就用nginx作为服务器了。</p><p>首先安装nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install nginx<br></code></pre></td></tr></table></figure><p>然后编写nginx的配置文件，在<code>/etc/nginx/nginx.conf</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> root;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><span class="hljs-attribute">include</span> /etc/nginx/modules-enabled/<span class="hljs-regexp">*.conf</span>;<br><span class="hljs-section">events</span> &#123;<br>        <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">768</span>;<br>        <span class="hljs-comment"># multi_accept on;</span><br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Basic Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">tcp_nodelay</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br>        <span class="hljs-attribute">types_hash_max_size</span> <span class="hljs-number">2048</span>;<br>        <span class="hljs-comment"># server_tokens off;</span><br><br>        <span class="hljs-comment"># server_names_hash_bucket_size 64;</span><br>        <span class="hljs-comment"># server_name_in_redirect off;</span><br><br>        <span class="hljs-attribute">include</span> /etc/nginx/mime.types;<br>        <span class="hljs-attribute">default_type</span> application/octet-stream;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># SSL Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>; <span class="hljs-comment"># Dropping SSLv3, ref: POODLE</span><br>        <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Logging Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">access_log</span> /var/log/nginx/access.log;<br>        <span class="hljs-attribute">error_log</span> /var/log/nginx/error.log;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Gzip Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><br>        <span class="hljs-comment"># gzip_vary on;</span><br>        <span class="hljs-comment"># gzip_proxied any;</span><br>        <span class="hljs-comment"># gzip_comp_level 6;</span><br>        <span class="hljs-comment"># gzip_buffers 16 8k;</span><br>        <span class="hljs-comment"># gzip_http_version 1.1;</span><br>        <span class="hljs-comment"># gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Virtual Host Configs</span><br>        <span class="hljs-comment">##</span><br><br><span class="hljs-comment">#这两行我注释了，否则配置文件貌似不会生效</span><br>        <span class="hljs-comment">#include /etc/nginx/conf.d/*.conf;</span><br>        <span class="hljs-comment">#include /etc/nginx/sites-enabled/*;</span><br><br>        <span class="hljs-comment"># server</span><br>        <span class="hljs-section">server</span> &#123;<br>                <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>                <span class="hljs-attribute">server_name</span> rrricardo.top;<br><br>                <span class="hljs-comment"># ssl settings</span><br>                <span class="hljs-attribute">ssl_certificate</span> /etc/letsencrypt/live/rrricardo.top/fullchain.pem;<br>                <span class="hljs-attribute">ssl_certificate_key</span> /etc/letsencrypt/live/rrricardo.top/privkey.pem;<br><br>                <span class="hljs-attribute">include</span> /etc/letsencrypt/options-ssl-nginx.conf;<br>                <span class="hljs-attribute">ssl_dhparam</span> /etc/letsencrypt/ssl-dhparams.pem;<br><br><br>                <span class="hljs-attribute">location</span> / &#123;<br>                        <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://rrricardo.top/blog/;<br>                &#125;<br><br>                <span class="hljs-attribute">location</span> /blog/ &#123;<br>                        <span class="hljs-attribute">root</span> /home/rcj/website/;<br>                        <span class="hljs-attribute">index</span> index.html index.htm;<br>                &#125;<br>        &#125;<br><br>        <span class="hljs-section">server</span> &#123;<br>                <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>                <span class="hljs-attribute">server_name</span> rrricardo.top;<br><br>                <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://$server_name$request_uri;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>nginx大部分的默认设置都没有改动，指设置了Let’s Encrypt提供的HTTPS证书以提供HTTPS服务，博客网站挂载在443端口的<code>/blog/</code>下，当访问443端口的<code>/</code>时会301重定向到<code>/blog/</code>上。</p><blockquote><p>安装Let’s Encrypt的服务主要参考<a href="https://letsencrypt.org/zh-cn/getting-started/">Let’s Encrypt</a>,<a href="https://certbot.eff.org/instructions?ws=nginx&os=ubuntufocal">Certbot Instructions | Certbot (eff.org)</a>,还有<a href="https://zhuanlan.zhihu.com/p/21286171">免费 https 证书（Let’s Encrypt）申请与配置 - 知乎 (zhihu.com)</a>。</p></blockquote><h3 id="网站备案"><a href="#网站备案" class="headerlink" title="网站备案"></a>网站备案</h3><p>按照你的云服务器提供商的指南进行就可以了，我的备案过程还算比较顺利。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从2021年9月15日博客仓库的首次提交到这篇博客完成，已经过去了七个月的时间，经过七个月不断的修补和改进，我的博客终于也算是有了一个博客的样子。</p><p>一路上读了许多人的博客，已经无法一一指出，在此一并表示感谢。</p><p>文中也不免有许多疏漏之处，因时间飞逝，当时遇到的一些问题也无法一一记录，还请诸位读者海涵。    </p>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostCalendar介绍</title>
    <link href="/blog/2022/03/05/PostCalendar%E4%BB%8B%E7%BB%8D/"/>
    <url>/blog/2022/03/05/PostCalendar%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="PostCalendar介绍"><a href="#PostCalendar介绍" class="headerlink" title="PostCalendar介绍"></a>PostCalendar介绍</h1><blockquote><p>本文是<a href="https://https//github.com/jackfiled/PostCalendarWindows">PostCalendarWindows</a>README文件的国内镜像</p></blockquote><p>一款集日程管理与DDL管理于一身的日历软件。 </p><p>下载地址：<a href="https://github.com/jackfiled/PostCalendarWindows/releases">GithubRelease</a></p><h1 id="开发未完成，仍在内测阶段"><a href="#开发未完成，仍在内测阶段" class="headerlink" title="开发未完成，仍在内测阶段"></a>开发未完成，仍在内测阶段</h1><span id="more"></span><h2 id="支持的功能"><a href="#支持的功能" class="headerlink" title="支持的功能"></a>支持的功能</h2><h3 id="日历部分"><a href="#日历部分" class="headerlink" title="日历部分"></a>日历部分</h3><p><img src="/blog/2022/03/05/PostCalendar%E4%BB%8B%E7%BB%8D/Calendar.png" alt="日历部分截图"></p><ol><li>支持日历事件的添加，删除，修改。</li><li>支持读取教务处自动生成的excel课表文件。</li></ol><blockquote><p>这个功能需要电脑上安装excel应用程序.</p><p>目前这个功能仅作实验性的支持，不保证excel读取的完全准确。</p><blockquote><p>使用帮助：在教务处网站“学期理论课表”页面有打印按钮，可以下载一个excel表格。</p><p>下载完成后，在软件里点击“导入excel课表”按钮，选择excel文件下载的位置，即可自动导入。</p></blockquote></blockquote><h3 id="DDL部分"><a href="#DDL部分" class="headerlink" title="DDL部分"></a>DDL部分</h3><p><img src="/blog/2022/03/05/PostCalendar%E4%BB%8B%E7%BB%8D/DDL.png" alt="DDL部分截图"></p><ol><li><p>支持DDL事件的添加，修改，完成，删除。</p></li><li><p>可以将活动界面中DDL类型的事件直接添加到个人DDL中。</p></li></ol><h3 id="活动部分"><a href="#活动部分" class="headerlink" title="活动部分"></a>活动部分</h3><p><img src="/blog/2022/03/05/PostCalendar%E4%BB%8B%E7%BB%8D/Activity.png" alt="活动部分截图"></p><p><strong>本部分未完成，设想中将与<a href="http://squidward.top/">DDL网站</a>的数据进行同步</strong></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>软件依赖于.net6.0，请点击<a href="https://dotnet.microsoft.com/zh-cn/download/dotnet/thank-you/runtime-desktop-6.0.2-windows-x64-installer">链接</a>下载.net6.0运行时。<br>在安装完成或者确认电脑上已安装.net6.0运行时之后，点击下载旁边的release包，双击下载文件中的PostCalendarWindows.exe即可使用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>环境配置备忘录</title>
    <link href="/blog/2022/01/15/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/blog/2022/01/15/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="环境配置备忘录"><a href="#环境配置备忘录" class="headerlink" title="环境配置备忘录"></a>环境配置备忘录</h1><p>电脑上的环境三天两头出问题，写下一个备忘录记录一下电脑上环境的配置过程。</p><span id="more"></span><blockquote><p>Update1: 2022年9月4日</p><p>重新配置了一遍电脑中的环境，删除了许多不切实际的地方。</p></blockquote><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>版本：Windows10专业版</p><p>版本号：21H2  </p><p>操作系统内部版本：19044.1949</p><p>体验：Windows Feature Experience Pack 120.2212.4180.0 </p><blockquote><p>虽然不知道上面的有什么用，但是还是写一下，没准什么时候就有用了。  </p></blockquote><h2 id="Windows-Subsystem-for-Linux-WSL"><a href="#Windows-Subsystem-for-Linux-WSL" class="headerlink" title="Windows Subsystem for Linux(WSL)"></a>Windows Subsystem for Linux(WSL)</h2><p>安装WSL的官方文档<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">链接</a> 。<br>输入<code>wsl -l -v</code>输出</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">  NAME      STATE           <span class="hljs-keyword">VERSION</span><br>* Ubuntu    <span class="hljs-literal">Stopped</span>         <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>即：使用的Linux分发版是Ubuntu，使用的WSL版本是WSL-2。</p><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>前往下载安装Python。</p><p>使用下列命令将pip下载换源为TUNA源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>在<a href="https://www.oracle.com/java/technologies/downloads/">这里</a>下载JDK ，然后配置相关的环境变量 ，首先设置JAVA_HOME，指向安装JDK的根路径。<br>然后是CALSSPATH，内容是</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">.;<span class="hljs-variable">%JAVA_HOME%</span><span class="hljs-symbol">\l</span>ib;<span class="hljs-variable">%JAVA_HOME%</span><span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\t</span>ools.jar;<br></code></pre></td></tr></table></figure><p>再设置PATH相关变量</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%JAVA_HOME%</span><span class="hljs-symbol">\b</span>in;<br><span class="hljs-variable">%JAVA_HOME%</span><span class="hljs-symbol">\j</span>re<span class="hljs-symbol">\b</span>in<br></code></pre></td></tr></table></figure><p>在PowerShell中输入</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">java <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>返回</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> <span class="hljs-number">17.0.4.1</span> <span class="hljs-number">2022</span>-<span class="hljs-number">08</span>-<span class="hljs-number">18</span> LTS<br><span class="hljs-attribute">Java</span>(TM) SE Runtime Environment (build <span class="hljs-number">17.0.4.1</span>+<span class="hljs-number">1</span>-LTS-<span class="hljs-number">2</span>)<br><span class="hljs-attribute">Java</span> HotSpot(TM) <span class="hljs-number">64</span>-Bit Server VM (build <span class="hljs-number">17.0.4.1</span>+<span class="hljs-number">1</span>-LTS-<span class="hljs-number">2</span>, mixed mode, sharing)<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">javac <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>返回</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">javac</span> <span class="hljs-number">17.0.4.1</span><br></code></pre></td></tr></table></figure><p>确认相关的设置完成 。</p><h4 id="JAVA-TOOL-OPTIONS"><a href="#JAVA-TOOL-OPTIONS" class="headerlink" title="JAVA_TOOL_OPTIONS"></a>JAVA_TOOL_OPTIONS</h4><p>设置一个环境变量<code>JAVA_TOOL_OPTIONS</code>为</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dfile</span>.</span></span>encoding=UTF8 -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Duser</span>.</span></span>language=en<br></code></pre></td></tr></table></figure><p>从而规避中文乱码的问题。</p><blockquote><p>其他一些官方文档较为全面，安装不需要复杂配置的编程语言就不再赘述了</p></blockquote><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><p>在<a href="https://code.visualstudio.com/">这里</a>下载。</p><h4 id="C-x2F-C-时的配置文件"><a href="#C-x2F-C-时的配置文件" class="headerlink" title="C&#x2F;C++时的配置文件"></a>C&#x2F;C++时的配置文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// launch.json</span><br>&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;</span>: [<br>        &#123;<span class="hljs-comment">//这个大括号里是我们的‘调试(Debug)’配置</span><br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Debug&quot;</span>,<span class="hljs-comment">//配置名称</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<span class="hljs-comment">//配置类型，cppdbg对应cpptools提供的调试功能；可以认为此处只能是cppdbg</span><br>            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<span class="hljs-comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span><br>            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;.out&quot;</span>,<span class="hljs-comment">// 将要进行调试的程序的路径</span><br>            <span class="hljs-attr">&quot;args&quot;</span>: [],<span class="hljs-comment">// 程序调试时传递给程序的命令行参数，这里设为空即可</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">// 设为true时程序将暂停在程序入口处，相当于在main上打断点</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/bin/&quot;</span>,<span class="hljs-comment">//程序的工作目录</span><br>            <span class="hljs-attr">&quot;environment&quot;</span>: [],<span class="hljs-comment">//环境变量，设置为空</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">// 为true时使用单独的cmd窗口，跳出小黑框；设为false则是用vscode的内置终端，建议用内置终端</span><br>            <span class="hljs-attr">&quot;internalConsoleOptions&quot;</span>: <span class="hljs-string">&quot;neverOpen&quot;</span>,<span class="hljs-comment">// 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，新手调试用不到</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<span class="hljs-comment">//指定特定的调试器</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;/usr/bin/gdb&quot;</span>,<span class="hljs-comment">//指定的调试器所在路径</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;build&quot;</span><span class="hljs-comment">// 调试开始前执行的任务，我们在调试前要编译构建。与tasks.json的label相对应，名字要一样</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// setting.json</span><br>&#123;<br>    <span class="hljs-attr">&quot;files.associations&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;stdio.h&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>,<br>        <span class="hljs-attr">&quot;xutility&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>,<br>        <span class="hljs-attr">&quot;stdlib.h&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>,<br>        <span class="hljs-attr">&quot;math.h&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>,<br>        <span class="hljs-attr">&quot;cmath&quot;</span>: <span class="hljs-string">&quot;c&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;C_Cpp.errorSquiggles&quot;</span>: <span class="hljs-string">&quot;EnabledIfIncludesResolve&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// tasks.json</span><br>&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>        &#123;<span class="hljs-comment">//这个大括号里是构建的配置文件</span><br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>,<span class="hljs-comment">//任务的名称</span><br>            <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;shell&quot;</span>,<span class="hljs-comment">//任务类型，process是vsc把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍</span><br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;gcc&quot;</span>,<span class="hljs-comment">//在shell中执行的命令，若编译C++改为g++</span><br>            <span class="hljs-attr">&quot;args&quot;</span>: [<span class="hljs-comment">//一些传递给命令的参数</span><br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>,<br>                <span class="hljs-string">&quot;-o&quot;</span>,<br>               <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;.out&quot;</span>,<span class="hljs-comment">//这里是生成exe程序的位置，因为我自己设置了bin文件夹的位置，因此我直接使用绝对路径</span><br>                <span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-comment">//生成和调试有关的信息</span><br>                <span class="hljs-string">&quot;-Wall&quot;</span>,<span class="hljs-comment">//开启额外警告</span><br>                <span class="hljs-string">&quot;-static-libgcc&quot;</span>,<span class="hljs-comment">//静态链接libgcc</span><br>                <span class="hljs-string">&quot;-lm&quot;</span>,<span class="hljs-comment">//链接一个库文件</span><br>                <span class="hljs-string">&quot;-std=c11&quot;</span>, <span class="hljs-comment">// 语言标准，可根据自己的需要进行修改，写c++要换成c++的语言标准，比如c++11</span><br>            ],<br>            <span class="hljs-attr">&quot;group&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>,<span class="hljs-comment">//表示这一组任务类型是构建</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span><span class="hljs-comment">//表示这个任务是当前这组任务中的默认任务</span><br>            &#125;,<br>            <span class="hljs-attr">&quot;presentation&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;echo&quot;</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//表示在执行任务时在终端要有输出</span><br>                <span class="hljs-attr">&quot;reveal&quot;</span>: <span class="hljs-string">&quot;always&quot;</span>,<span class="hljs-comment">//执行任务时是否跳转到终端面板，可以为always，silent，never</span><br>                <span class="hljs-attr">&quot;focus&quot;</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">//设为true后可以使执行task时焦点聚集在终端，但对编译来说，设为true没有意义，因为运行的时候才涉及到输入</span><br>                <span class="hljs-attr">&quot;panel&quot;</span>: <span class="hljs-string">&quot;new&quot;</span>,<span class="hljs-comment">//每次执行这个task时都新建一个终端面板，也可以设置为shared，共用一个面板，不过那样会出现‘任务将被终端重用’的提示，比较烦人</span><br>                <span class="hljs-attr">&quot;showReuseMessage&quot;</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">&quot;clear&quot;</span>: <span class="hljs-literal">false</span><br>            &#125;,<br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span>:<span class="hljs-string">&quot;$gcc&quot;</span>,<span class="hljs-comment">////捕捉编译时编译器在终端里显示的报错信息，将其显示在vscode的‘问题’面板里</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;run&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;dependsOn&quot;</span>:<span class="hljs-string">&quot;build&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>:<span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;.out&quot;</span>,<span class="hljs-comment">//这里是运行生成的程序的命令，同样使用绝对路径</span><br>            <span class="hljs-attr">&quot;group&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;test&quot;</span>,<br>                <span class="hljs-attr">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span>,<br>            &#125;,<br>            <span class="hljs-attr">&quot;presentation&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;echo&quot;</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">&quot;reveal&quot;</span>: <span class="hljs-string">&quot;always&quot;</span>,<br>                <span class="hljs-attr">&quot;focus&quot;</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">////这个就设置为true了，运行任务后将焦点聚集到终端，方便进行输入</span><br>                <span class="hljs-attr">&quot;panel&quot;</span>: <span class="hljs-string">&quot;new&quot;</span>,<br>                <span class="hljs-attr">&quot;showReuseMessage&quot;</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">&quot;clear&quot;</span>: <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Jetbrians"><a href="#Jetbrians" class="headerlink" title="Jetbrians"></a>Jetbrians</h3><p>使用<code>Jetbrains Toolbox</code>来管理电脑上的所有IDE。</p><h2 id="终端美化"><a href="#终端美化" class="headerlink" title="终端美化"></a>终端美化</h2><p>首先在微软应用商店下载安装<code>Windows Terminal</code>。</p><h3 id="PowerShell美化"><a href="#PowerShell美化" class="headerlink" title="PowerShell美化"></a>PowerShell美化</h3><p>前往<a href="https://github.com/jandedobbeleer/oh-my-posh">oh-my-posh</a>下载这个Powershell的美化工具，将安装的位置放进<code>PATH</code>环境变量中，在终端中输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">oh</span><span class="hljs-literal">-my</span><span class="hljs-literal">-posh</span> -<span class="hljs-literal">-version</span><br></code></pre></td></tr></table></figure><p>确认是否安装成功。</p><p>同时将下载下来的主题文件放在一个特定的地方（我这里是<code>C:\Users\ricardo\Programs\oh-my-posh\themes</code>），在PowerShell的启动配置文件<code>$PROFILE</code>中加入下面几句</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-Item</span> env:POSH_THEMES_PATH <span class="hljs-string">&quot;C:\Users\ricardo\Programs\oh-my-posh\themes&quot;</span><br><span class="hljs-built_in">oh</span><span class="hljs-literal">-my</span><span class="hljs-literal">-posh</span> init pwsh -<span class="hljs-literal">-config</span> <span class="hljs-string">&quot;<span class="hljs-variable">$env:POSH_THEMES_PATH</span>/paradox.omp.json&quot;</span> | <span class="hljs-built_in">Invoke-Expression</span><br></code></pre></td></tr></table></figure><p>下载<a href="https://github.com/dahlbyk/posh-git">posh-git</a>，这是一个给PowerShell提供Git相关辅助的模块，下载完成之后，将下列命令添加到<code>$PROFILE</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Import-Module</span> ~\Programs\posh<span class="hljs-literal">-git</span>\src\posh<span class="hljs-literal">-git</span>.psd1<br></code></pre></td></tr></table></figure><p>如果在修改了配置文件之后启动提示运行脚本没有经过签名，可以采用下面这条命令来修改运行脚本的权限：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-ExecutionPolicy</span> <span class="hljs-literal">-ExecutionPolicy</span> Bypass <span class="hljs-literal">-Scope</span> CurrentUser<br></code></pre></td></tr></table></figure><p>再重新运行配置文件就没有问题了。</p><p><img src="/blog/2022/01/15/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png" alt="终端预览"></p><h3 id="PowerShell配置文件"><a href="#PowerShell配置文件" class="headerlink" title="PowerShell配置文件"></a>PowerShell配置文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># oh-my-posh setup</span><br><span class="hljs-built_in">oh</span><span class="hljs-literal">-my</span><span class="hljs-literal">-posh</span> init pwsh -<span class="hljs-literal">-config</span> <span class="hljs-string">&quot;C:\Users\ricardo\Programs\oh-my-posh\themes\paradox.omp.json&quot;</span> | <span class="hljs-built_in">Invoke-Expression</span><br><br><span class="hljs-built_in">Import-Module</span> ~\Programs\posh<span class="hljs-literal">-git</span>\src\posh<span class="hljs-literal">-git</span>.psd1<br><br><span class="hljs-comment"># proxy functions</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set-Proxy</span></span> &#123;<br>    <span class="hljs-built_in">Set-Item</span> Env:http_proxy <span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span><br>    <span class="hljs-built_in">Set-Item</span> Env:https_proxy <span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Remove-Proxy</span></span> &#123;<br>    <span class="hljs-built_in">Remove-Item</span> Env:http_proxy<br>    <span class="hljs-built_in">Remove-Item</span> Env:https_proxy<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="WSL美化"><a href="#WSL美化" class="headerlink" title="WSL美化"></a>WSL美化</h3><p>目前我还在使用<code>bash</code>，不过使用<code>oh-my-posh</code>进行了一定的美化。</p><p>同Windows下一致进行<code>oh-my-posh</code>的下载和安装，在<code>~/.bashrc</code>中添加这样一句配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(oh-my-posh init bash --config /home/ricardo/.poshthemes/paradox.omp.json)</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="BASH设置"><a href="#BASH设置" class="headerlink" title="BASH设置"></a>BASH设置</h3><p>在<code>~/.bashrc</code>文件的末尾新增</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># oh-my-posh setup</span><br><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(oh-my-posh init bash --config /home/ricardo/.poshthemes/paradox.omp.json)</span>&quot;</span><br><br><span class="hljs-comment"># proxy function</span><br><span class="hljs-built_in">export</span> hostip=$(cat /etc/resolv.conf | grep <span class="hljs-string">&quot;nameserver&quot;</span> | cut -f 2 -d <span class="hljs-string">&quot; &quot;</span>)<br><br><span class="hljs-function"><span class="hljs-title">proxy</span></span>()<br>&#123;<br>    <span class="hljs-built_in">export</span> http_proxy = <span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br>    <span class="hljs-built_in">export</span> https_proxy = <span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:7890&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">unproxy</span></span>()<br>&#123;<br>    <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment"># alias settings</span><br><span class="hljs-built_in">alias</span> python=python3<br></code></pre></td></tr></table></figure><h2 id="其他的小工具"><a href="#其他的小工具" class="headerlink" title="其他的小工具"></a>其他的小工具</h2><p>字体：</p><ul><li><a href="https://github.com/tonsky/FiraCode">Fira Code</a></li></ul><p>命令行工具</p><ul><li><a href="https://github.com/bootandy/dust">dust</a></li><li><a href="https://github.com/boyter/scc">scc</a></li><li><a href="https://github.com/cloverstd/tcping">tcping</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年终总结</title>
    <link href="/blog/2022/01/12/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2022/01/12/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="2021年终总结"><a href="#2021年终总结" class="headerlink" title="2021年终总结"></a>2021年终总结</h1><p>2021年已经过去，2022年已经来临。每每一年开始的时候，我都会展开一张纸或者新建一个文档，思量着又是一年时光，也该同诸大杂志一般，写几句意味深长的话语，怀念过去的时光，也祝福未来的自己。可往往脑海中已是三万字的长篇，落在笔头却又是一个字都没有了。<br>如今跨年的时候已经过去，朋友圈中已经不见文案的踪影，我也该重新提笔，细说自己2021年中做过的种种。  </p><span id="more"></span><h2 id="高考，落下帷幕"><a href="#高考，落下帷幕" class="headerlink" title="高考，落下帷幕"></a>高考，落下帷幕</h2><p>在未来我回想2021时，想到的第一个念头必然是“高考”，都说高考时人生中最重要的分水岭，这次考试不仅把我送进了911大学——北京邮电大学，也标志着一个时代的结束。  </p><h2 id="MY中学杂记"><a href="#MY中学杂记" class="headerlink" title="MY中学杂记"></a>MY中学杂记</h2><p>仍然记得，在高中的最后一个寒假，高考前最后一个比较长的假期，我还是没有能够提前写完作业，把有限的时间投入无限的复习大业中去。仍然是到了假期的最后一天再来补作业。<br>仍然记得，在高考的理综结束之后，我差点跪在铭志楼的楼梯上。<br>仍然记得，在那天的中午，我们几乎没有吃饭，寝室里出人意料的安静。<br>仍然记得，在最后的宴会上，我们共同举杯，祝福我们的未来。  </p><h2 id="暑假，说好的狂欢？"><a href="#暑假，说好的狂欢？" class="headerlink" title="暑假，说好的狂欢？"></a>暑假，说好的狂欢？</h2><p>在前12年的学生生涯中，我们都在期待着这一次的暑假，以为在这个没有作业的假期里，我们就可以充分的享受人间的美好。可是，当时我们不知道，这人间的烦恼，可不止作业这一种，无论是突如其来的疫情导致开学延期，还是等待录取时的不安。<br>虽说在暑假时，拥有了自己的笔记本电脑，可是在高中三年屯下的游戏还是没有玩几个，看来我也是“喜加一”的受害者。虽然在高考后入坑了原神，但是假期间我并没有太过投入的玩。<br>暑假下定决心要好好的学一学，可是看着我gitee上暑假期间那稀疏的提交，我就知道我又摸了一个暑假的鱼。  </p><img src="/blog/2022/01/12/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/1.png" class title="gitee提交">  <p>即使我想写的很多项目都没有被扎实的推进下来，但是学习的一些的C语言还是让我受益匪浅。<br>现在看来，这个假期真是，<strong>学也没有学好，耍也没有耍好</strong>的典型。   </p><h2 id="BUPT——新的开始"><a href="#BUPT——新的开始" class="headerlink" title="BUPT——新的开始"></a>BUPT——新的开始</h2><p>尽管有着烦人的疫情，我们还是在2021年9月8日顺利走进了北邮的校园。<br><del>虽然校园很小，但是</del>校园第一眼给人的印象还是蛮大的。走在贯穿东西的主干道上，我们逐渐地熟悉校园中的建筑物。<br>在刚开学的时候，北邮放假永不调休的制度着实让我们大吃一惊，毕竟连着中秋加国庆加周末几乎放掉了半个月，这难道是一般人能承受的吗？更不要说我们这群刚刚放了三个月的暑假，已经不知道学习是什么东西的freshman了。<br>刚刚享受玩国庆假期的我们，就又被疫情坑了一把，半个学期就这样被我们混了过去，除了把半个寝室都带进了原神的坑里，其他的我啥也没干。<br>紧接着就是噩梦一样的体测+半期考试+秋之韵三板斧，这难道是一般人能承受的吗？<del>反复以表示强调</del><br>再然后就是期末考试提前，高数与线代的课时数严重不足，其他几科也是组织完期中考试就准备期末考试，总之就是这个学期没有下半期这个说法了。<br>这个学期就结束了。<br><strong>总结：啥也没干</strong>   </p><h2 id="说说技术"><a href="#说说技术" class="headerlink" title="说说技术"></a>说说技术</h2><p>在北邮的一个学期，虽然学到的的新东西不多，但是自己C语言的能力是有了切实的提高。在大学之前也很少接触这种OJ平台的代码训练，这个学期也算是涨了见识。<br>这个学期说好精进一下自己Python相关的技术，结果这个学期Python是我写的最少的一门语言。这个学期反而接触了许多新鲜的语言，比如Java，C#，Javascript等等。自己也租用了阿里云的云服务器，在上面部署了自己的博客和一些小工具。除了语言方面的接触，这个学期对于智能硬件的接触也算是比较对，针对选修课“基于Arduino的开源手机设计”熟悉了Arduino编程控制相关的知识，自己也购买了一套Arduino开发板，打算下学期做点有意思的小工作。<br>在学院的综合影视部干了一年，我也算是接触了直播的相关流程，对需要的技术栈有了一个初步的了解。还研究过V家编辑器，感觉自己没用技能又增加了。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2021年就是，虽然没有什么大的收获，但一些小小的进步总让我们确信未来会更好。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计与计算导论笔记</title>
    <link href="/blog/2021/11/17/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2021/11/17/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="程序设计与计算导论笔记"><a href="#程序设计与计算导论笔记" class="headerlink" title="程序设计与计算导论笔记"></a>程序设计与计算导论笔记</h1><p>直接扒的老黄的PPT ，简直毫无参考价值。<br>不保证笔记的绝对正确性。<br>如果导致考试爆炸，不承担任何责任。</p><span id="more"></span>     <h2 id="第一章——程序设计概论"><a href="#第一章——程序设计概论" class="headerlink" title="第一章——程序设计概论"></a>第一章——程序设计概论</h2><img src="/blog/2021/11/17/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/1.png" class title="第一章"><h2 id="第二章——C语言概述"><a href="#第二章——C语言概述" class="headerlink" title="第二章——C语言概述"></a>第二章——C语言概述</h2><img src="/blog/2021/11/17/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/2.png" class title="第二章1"><img src="/blog/2021/11/17/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/3.png" class title="第二章2">]]></content>
    
    
    
    <tags>
      
      <tag>学习资料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装pytorch，来有深度的学习</title>
    <link href="/blog/2021/11/13/%E5%AE%89%E8%A3%85pytorch%EF%BC%8C%E6%9D%A5%E6%9C%89%E6%B7%B1%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2021/11/13/%E5%AE%89%E8%A3%85pytorch%EF%BC%8C%E6%9D%A5%E6%9C%89%E6%B7%B1%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习预备篇——安装深度学习框架——pytorch"><a href="#深度学习预备篇——安装深度学习框架——pytorch" class="headerlink" title="深度学习预备篇——安装深度学习框架——pytorch"></a>深度学习预备篇——安装深度学习框架——pytorch</h1><span id="more"></span><h2 id="pytorch简介"><a href="#pytorch简介" class="headerlink" title="pytorch简介"></a>pytorch简介</h2><p>现在我们正处在人工智能的风口上，虽然话说得好“在风口上，一头猪都能起飞”，但是我们显然没法像猪一样飞起来，但是跑两步，至少装一个可以运行人工智能的环境是可以的，就算没法吃猪肉，也得看看猪跑。  </p><p><code>pytorch</code>就是一个开源的<code>python</code>机器学习框架，主要由<code>facebook</code>的人工智能团队开发。这个框架采用类似于<code>numpy</code>的张量计算，可以使用GPU进行加速，有着自动微分系统的深度学习模块。</p><h2 id="安装pytorch"><a href="#安装pytorch" class="headerlink" title="安装pytorch"></a>安装pytorch</h2><h3 id="conda的简介"><a href="#conda的简介" class="headerlink" title="conda的简介"></a>conda的简介</h3><p>我们首先要明确的是，<code>pytorch</code>是一个开源的python深度学习库，在安装pytorch之前我们得先安装python解释器。可能有人会说，安装python解释器难道不是小学二年级的内容吗，无非是下载python，添加到环境变量，再命令行输入python验证安装是否完成三部曲。这难道是很困难的事情吗？    </p><p>可如果我们的在<del>生活中</del>学习中需要用到多个不同的python环境怎么办？安装多个python解释器之后如何在不同的环境中切换？而且可能在不同的版本下所用的库的版本还不尽相同，这时候我们就需要一个便捷的”环境管理器“来管理你电脑上的python环境了，这个管理器便是<code>conda</code>。再安装了<code>conda</code>之后，我们就可以在电脑里创建一个个”独立“的python环境，每个环境可以有不同的解释器，不同的库。可以说是十分方便了。   </p><blockquote><p>比如在复现其他人的研究成果的时候，他所用的<code>pytorch</code>版本和你的不一样，甚至你们的<code>python</code>解释器的版本都不一定完全相同。</p></blockquote><blockquote><p>至少一行命令就可以安装python，这已经很香了<br>而且<code>conda</code>在安装需要的库时，会自动的分析依赖，可以在一定程度上解决环境总是崩溃的问题。</p></blockquote><h3 id="安装conda"><a href="#安装conda" class="headerlink" title="安装conda"></a>安装conda</h3><p>在安装<code>conda</code>的时候，我们可以选择安装<code>anaconda</code>这个Python发行版，这是一个致力于简化在科学计算中包管理和部署的发行版。</p><p>但是这个的问题在于他过于的全面，而我们只是想要安装自己需要的包，因此我选择<code>miniconda</code>这个简化的<code>conda</code>安装方式，这个安装包中就只有<code>conda</code>和<code>python</code>两个程序。同时可以利用<code>conda</code>和<code>pip</code>这两个包管理器安装<code>anaconda</code>和<code>pypi</code>这两个包仓库中的所有包。</p><blockquote><p>这两者的比较，也可以参看<a href="https://docs.conda.io/projects/conda/en/latest/user-guide/install/download.html#anaconda-or-miniconda">官方文档</a></p></blockquote><p>我们访问<code>miniconda</code>的<a href="https://docs.conda.io/en/latest/miniconda.html">官方网站</a> ，下滑找到最新的<code>miniconda</code>安装包下载链接（Latest Miniconda Installer Links）。 </p><p><img src="/blog/2021/11/13/%E5%AE%89%E8%A3%85pytorch%EF%BC%8C%E6%9D%A5%E6%9C%89%E6%B7%B1%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0/1.png"></p><p>按照自己的电脑系统下载相应的安装包就可以了。也不大，就50M出头的样子。</p><p>下载完成之后，我们运行这个安装包，一路下一步就可以了，一般情况下不会有什么要改动的地方。   </p><p>安装完成之后，我们就会发现自己的开始菜单里多出来了两个快捷方式,</p><p><img src="/blog/2021/11/13/%E5%AE%89%E8%A3%85pytorch%EF%BC%8C%E6%9D%A5%E6%9C%89%E6%B7%B1%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0/2.png"><br>在上面的那个快捷方式<strong>Anaconda Prompt</strong>是运行含有<code>conda</code>命令的CMD的快捷方式，而下面那个<strong>Anaconda Power Shell Prompt</strong>是运行含有<code>conda</code>命令的Power shell界面的快捷方式。因为我个人对于power shell更加的熟悉我们就是用下面的那个快捷方式。   </p><p>这个时候肯定会有人好奇，竟然你都用power shell了，我们为啥不直接使用系统里已经有了的power shell，而要启动这里的这个显得有点奇怪的power shell呢？     </p><p>如果你好奇，你可以在系统里的power shell里键入<code>conda</code>, 会发现系统会告诉你<code>conda并不是内部化外部应用程序</code>，马上又有人会说，这个表示<code>conda</code>这个程序所在的位置没有被添加进入系统的环境变量里，如果添加了之后就可以在系统的power shell里使用了，而且我在安装<code>miniconda</code>的时候，还看见了添加到环境变量的选项，只是默认的情况下没有勾选。确实，在默认的状态下，<code>conda</code>并不会被添加在环境变量中，因为在<code>conda</code>的所在目录下还有<code>python</code>，如果你将<code>conda</code>添加进入了环境变量，就有可能改变原来了系统自带的<code>python</code>解释器。所以在默认情况下<code>conda</code>是不会被添加到环境变量中的。不过如果你的电脑中并没有<code>python</code>，或者像我一样直接采用<code>conda</code>来管理电脑上的<code>python</code>环境，也可以直接将<code>conda</code>添加在环境变量中，而且在后面我们使用<code>VSCode</code>编写代码的时候，我们只有将<code>conda</code>添加进入环境变量，才可以直接运行代码。<del>当然，大概率还是有其它的办法，只是我太菜了不知道</del>    </p><p>好，我们运行<strong>Anaconda Power Shell Prompt</strong>，打开了这个窗口</p><p><img src="/blog/2021/11/13/%E5%AE%89%E8%A3%85pytorch%EF%BC%8C%E6%9D%A5%E6%9C%89%E6%B7%B1%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0/3.png"></p><p>这个窗口的出现就标志着我们已经把<code>conda</code>正确的安装在我们的电脑之中了。</p><h3 id="conda的使用"><a href="#conda的使用" class="headerlink" title="conda的使用"></a>conda的使用</h3><p>我们很容易发现，这个power shell与我们常用的power shell之家最大的不同就是在PS的前面多了一个（base），这个括号就表示我们目前所处的环境是<code>conda</code>自动生成的初始环境(base环境)。<br>在我安装的时候，这个环境的python版本是3.9，一会我们就会在这个环境之中安装我们本文的主角<strong>pytorch</strong>,不过在安装之前，我们先来熟悉一下<code>conda</code>，毕竟我们会使用这个包管理器来安装我们需要用到的大部分包。   </p><h4 id="使用conda创建与删除环境"><a href="#使用conda创建与删除环境" class="headerlink" title="使用conda创建与删除环境"></a>使用conda创建与删除环境</h4><blockquote><p>在没有指明的情况下，请在<strong>Anaconda Powershell Prompt</strong>环境中使用以下的命令</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">conda</span> <span class="hljs-literal">info</span> -e<br></code></pre></td></tr></table></figure><p>这个命令会展示目前系统中已经创建的环境，输入后的效果：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"># conda environments:<br>#<br>base                  *  C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\r</span>icardo.DESKTOP-N6OVBK5<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\m</span>iniconda3<br>py310                    C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\r</span>icardo.DESKTOP-N6OVBK5<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\m</span>iniconda3<span class="hljs-symbol">\e</span>nvs<span class="hljs-symbol">\p</span>y310<br></code></pre></td></tr></table></figure><p>其中会指出环境所在的文件夹，星号标志当前所处的环境。  </p><blockquote><p>这里也可以使用<code>conda env list</code></p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create --name newev python=<span class="hljs-number">3</span>.<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>使用这个命令来在创建一个新的环境，这个环境的由“–name”之后的内容决定，这个环境的python解释器版本由python&#x3D;决定，注意这里的环境只用指定到3.x，<code>conda</code>会自动寻找这个系列下最新的版本安装。<br>在创建了一个环境之后，使用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> &lt;envirname&gt;<br></code></pre></td></tr></table></figure><p>来切换到相应的环境，<code>envirname</code>是你自己指定的环境的名称。  </p><p>如果像退出这个环境，回到<code>conda</code>的默认环境，使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda deactivate</span><br></code></pre></td></tr></table></figure><p>再使用这个命令之后，我们就会回到base环境，我们可以通过看PS前面的名字来确认这一点。   </p><h4 id="使用conda管理自己的库"><a href="#使用conda管理自己的库" class="headerlink" title="使用conda管理自己的库"></a>使用conda管理自己的库</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda list</span><br></code></pre></td></tr></table></figure><p>这个命令会展示在在当前环境中安装的包。而且注意，虽然我们使用的是<code>conda</code>来管理与安装库，但是这并不表示python自带的pip包管理工具就被废弃，而且就算你通过pip安装的python库页会被<code>conda</code>上面的命令正确的识别到。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">conda list -n <span class="hljs-tag">&lt;<span class="hljs-name">envirname</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用这个命令来查看指定的环境中安装的包。    </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">conda <span class="hljs-built_in">search</span> <span class="hljs-symbol">&lt;pkgname&gt;</span><br></code></pre></td></tr></table></figure><p>搜索指定的包的信息，比如我输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda search numpy</span><br></code></pre></td></tr></table></figure><p><code>conda</code>会给我返回</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">Loading channels: done<br><span class="hljs-comment"># Name                       Version           Build  Channel</span><br>······<br>numpy                         <span class="hljs-number">1.21</span>.<span class="hljs-number">2</span>  py37hfca59bb_0  anaconda<span class="hljs-regexp">/pkgs/m</span>ain<br>numpy                         <span class="hljs-number">1.21</span>.<span class="hljs-number">2</span>  py38hfca59bb_0  anaconda<span class="hljs-regexp">/pkgs/m</span>ain<br>numpy                         <span class="hljs-number">1.21</span>.<span class="hljs-number">2</span>  py39hfca59bb_0  anaconda<span class="hljs-regexp">/pkgs/m</span>ain<br></code></pre></td></tr></table></figure><p><code>conda</code>就会返回给我们包的版本，相关的python版本，下载的渠道  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">conda install <span class="hljs-tag">&lt;<span class="hljs-name">pkgname</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用这个命令在当前所处的环境里安装我们所需要的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">conda install -n <span class="hljs-tag">&lt;<span class="hljs-name">envname</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">pkgname</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用“-n”参数来指定一个环境安装我们需要的包</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">conda <span class="hljs-keyword">update</span> -n <span class="hljs-symbol">&lt;envname&gt;</span> <span class="hljs-symbol">&lt;pkgname&gt;</span><br></code></pre></td></tr></table></figure><p>使用这个命令来更新指定的包</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">conda <span class="hljs-built_in">remove</span> -n <span class="hljs-symbol">&lt;envname&gt;</span> <span class="hljs-symbol">&lt;pkgname&gt;</span><br></code></pre></td></tr></table></figure><p>使用这个命令删除指定环境中我们所不需要的包<br>分别使用</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">conda <span class="hljs-keyword">update</span> conda <br>conda <span class="hljs-keyword">update</span> <span class="hljs-keyword">python</span><br></code></pre></td></tr></table></figure><p>来升级<code>conda</code>与<code>python</code></p><blockquote><p>注意，假设现在python版本是3.5，则只会升级到3.5系列的最新版</p></blockquote><h4 id="使用conda的国内镜像源"><a href="#使用conda的国内镜像源" class="headerlink" title="使用conda的国内镜像源"></a>使用conda的国内镜像源</h4><p>由于部分原因，使用conda的默认镜像源安装我们需要的库可能花费的时间较长，或者提示网络连接失败等等。为了解决这个问题，我们可以使用清华大学提供的镜像源，镜像站提供了相关设置的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">帮助文档</a>，根据文档的指示一步步设置就可以了。   </p><h3 id="使用conda安装pytorch"><a href="#使用conda安装pytorch" class="headerlink" title="使用conda安装pytorch"></a>使用conda安装pytorch</h3><p>我们访问pytorch的<a href="https://pytorch.org/">官方网站</a>,我们可以轻松在首页就找到这个表格<br><img src="/blog/2021/11/13/%E5%AE%89%E8%A3%85pytorch%EF%BC%8C%E6%9D%A5%E6%9C%89%E6%B7%B1%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0/4.png"><br>先简单介绍一下这个表格的每一行，第一行是选择我们安装<code>pytorch</code>的版本，是稳定版，预览版，还是长期支持版。第二行是选择我们索要下载的操作系统，这里就默认大家都是用Windows了，第三行是选择我们安装<code>pytorch</code>的方式，可以看见有我们刚学习的<code>conda</code>，我们很熟悉的<code>pip</code>, 还有两种其他的方式。我们选择<code>conda</code>。第三行是我们所使用的语言，我们自然选择<code>python</code>。然后是第四行，“Compute Platform”， 如果直译的话是计算平台，就是我们选择用来计算的设备。这里就是又一个新的知识点了。一般来说，我们在使用电脑时，都是使用CPU作为计算的主力，显卡（GPU)一般只是用来输出图像，但在深度学习出现后，人们发现显卡原本专精于图形计算的计算力也很适用于深度学习中人工神经网络的计算。为了能够使用GPU的算力，而不是让它仅仅输出图像，我们就得下载相关的工具，这个工具就是CUDA。当然，这种比较强大的能力并不是只要下载一个CUDA就可以拥有的，<del>你还得有钱</del>你还得拥有一块英伟达的显卡，如果你没有显卡，那你就只能老老实实的使用自己的CPU进行计算了，在表格的第四行选择CPU。而对于我们<del>土豪</del>有显卡的同学，我们得先确定确定自己电脑上CUDA的版本，打开我们的老朋友power shell，输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvidia-smi</span><br></code></pre></td></tr></table></figure><p>这是英伟达显卡的一个监控命令，可以看见当前GPU的使用情况，我们从这里来看自己的CUDA版本。</p><p>在我的RTX3060笔记本上，输出是这样的</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">Mon Nov 15 10:43:50 2021<br>+-----------------------------------------------------------------------------+<br>|<span class="hljs-string"> NVIDIA-SMI 462.36       Driver Version: 462.36       CUDA Version: 11.2     </span>|<br>|<span class="hljs-string">-------------------------------+----------------------+----------------------+</span><br><span class="hljs-string"></span>|<span class="hljs-string"> GPU  Name            TCC/WDDM </span>|<span class="hljs-string"> Bus-Id        Disp.A </span>|<span class="hljs-string"> Volatile Uncorr. ECC </span>|<br>|<span class="hljs-string"> Fan  Temp  Perf  Pwr:Usage/Cap</span>|<span class="hljs-string">         Memory-Usage </span>|<span class="hljs-string"> GPU-Util  Compute M. </span>|<br>|<span class="hljs-string">                               </span>|<span class="hljs-string">                      </span>|<span class="hljs-string">               MIG M. </span>|<br>|<span class="hljs-string">===============================+======================+======================</span>|<br>|<span class="hljs-string">   0  GeForce RTX 306... WDDM  </span>|<span class="hljs-string"> 00000000:01:00.0 Off </span>|<span class="hljs-string">                  N/A </span>|<br>|<span class="hljs-string"> N/A   49C    P0    19W /  N/A </span>|<span class="hljs-string">    121MiB /  6144MiB </span>|<span class="hljs-string">      0%      Default </span>|<br>|<span class="hljs-string">                               </span>|<span class="hljs-string">                      </span>|<span class="hljs-string">                  N/A </span>|<br>+-------------------------------+----------------------+----------------------+<br><br>+-----------------------------------------------------------------------------+<br>|<span class="hljs-string"> Processes:                                                                  </span>|<br>|<span class="hljs-string">  GPU   GI   CI        PID   Type   Process name                  GPU Memory </span>|<br>|<span class="hljs-string">        ID   ID                                                   Usage      </span>|<br>|<span class="hljs-string">=============================================================================</span>|<br>|<span class="hljs-string">  No running processes found                                                 </span>|<br>+-----------------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><blockquote><p>注意：以下内容仅供参考，我只能说，我这样是成功了的，不代表所有人都可以成功</p></blockquote><p>在表格的第一行，我们可以看见我电脑上CUDA的版本是11.2，我们回到<code>pytorch</code>的官网，发现它的表格中只有cuda10.2与cuda11.3两个版本供我们选择，虽然我的电脑上的<code>cuda</code>只是11，2的，但是我选择的仍是cuda11.3版本的，因为3060貌似是不支持cuda10的了。<del>玄学开始了</del>我们在表格中选择完之后，就会得到一句命令，把这个命令复制到<strong>Anaconda Power shell Prompt</strong>中去运行，在提示确认的地方回车，就会开始下载安装<code>pytorch</code>，我们耐心等待一段时间。<br>在安装完成之后，我们来到了<del>最激动人心的</del>验证安装是否成功以及cuda是否能够被正确调用的环节，我们首先输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda list</span><br></code></pre></td></tr></table></figure><p>查看当前的环境中是否已经有<code>pytorch</code>这个库，一般来说，这一步不会有大问题。<br>然后我们输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">python</span><br></code></pre></td></tr></table></figure><p>打开python的交互式解释器，输入</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> torch<br></code></pre></td></tr></table></figure><p>看看能否正确的导入这个库，这个导入的过程可能有点长，不要紧张    </p><p>如果这锅过程没有报错的话，就说明导入正常了，我们简单的使用一下这个库来进一步判断，输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">x = torch<span class="hljs-selector-class">.rand</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(x)</span></span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">tensor(<span class="hljs-string">[[0.7280, 0.0764, 0.1278, 0.0408, 0.8655],</span><br><span class="hljs-string">        [0.8270, 0.2127, 0.1831, 0.0908, 0.6578],</span><br><span class="hljs-string">        [0.8396, 0.4007, 0.2550, 0.8508, 0.4947]]</span>)<br></code></pre></td></tr></table></figure><p>这里是输出的均是随机数，如果数不一样才正常。</p><p>我们在验证一下是否可以调用<code>cuda</code>, 输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(torch.cuda.is_available()</span></span>)<br></code></pre></td></tr></table></figure><p>如果输出True就是皆大欢喜，安装成功，如果输出False，那<del>建议放弃治疗</del>我也爱莫能助，毕竟我这一路下来虽然在<code>cuda</code>的版本上有点不对劲的地方，但他就是给我返回了</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在安装<code>pytorch</code>的这一路下来，我在网上查了无数的资料，似乎在安装<code>pytorch</code>的一路上就死了不少的人<del>大概是因为他们是在Ubuntu上安装的</del>，特别是调用<code>cuda</code>的那里。不过我按照<a href="https://pytorch.org/get-started/locally/">官方文档</a>一路下来，没有出什么大的幺蛾子，只能说希望我自己的经历能对大家有所帮助吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在浏览器中打开VSCode</title>
    <link href="/blog/2021/10/30/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%93%E5%BC%80VSCode/"/>
    <url>/blog/2021/10/30/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%93%E5%BC%80VSCode/</url>
    
    <content type="html"><![CDATA[<h1 id="无论何处，都可以使用自己定制的VSCode开发环境"><a href="#无论何处，都可以使用自己定制的VSCode开发环境" class="headerlink" title="无论何处，都可以使用自己定制的VSCode开发环境"></a>无论何处，都可以使用自己定制的VSCode开发环境</h1><p>众所周知，VSCode作为大微软家开发的开源编辑器，一经发布便受到了两广大程序员群体的欢迎。如果我们深入的了解一下VSCode，就会知道VSCode是基于Electron框架构建的Web应用程序，而Electron框架是基于Web技术来开发桌面应用程序，即VSCode只要稍加改造，就可以流畅的在浏览器中运行。那么我们如何才能在浏览器打开一个VSCode呢？<br>最简单的方法是在浏览器中输入<a href="https://vscode.dev/">这个网址</a>，就可以在浏览器中打开一个VSCode Online，这个版本的VSCode可以支持打开本地的文件，并且进行编辑。不过这个编辑器并不支持大部分的插件，而且并不支持程序的编译与运行，并不是一个可以开箱即用的编辑器。那么还有什么办法可以让我们拥有一个联网即可得的个人定制化开发环境呢？   </p><span id="more"></span><h2 id="采用code-server搭建自己的VSCode-Online服务器端"><a href="#采用code-server搭建自己的VSCode-Online服务器端" class="headerlink" title="采用code-server搭建自己的VSCode Online服务器端"></a>采用code-server搭建自己的VSCode Online服务器端</h2><p>code-server是一家第三方公司开发的VSCode Online的服务器端，在你自己的服务器上安装这个软件之后，你就可以通过你自己指定的网址访问位于自己服务器上的VSCode了。   </p><blockquote><p>要是你没有服务器？ 可以去各大云服务器提供商那里购买一台云服务器。</p></blockquote><p>我这里采用自己在阿里云上购买的轻量应用服务器上部署自己的VSCode服务器，这台轻量应用服务器有着2核2G，60GESSD的配置，对于一个VSCode来说是绰绰有余，而且这个套餐提供了最高5M的带宽，较宽的带宽使自己网页中打开VSCode的速度大大提高，极大的提升了使用体验。大家自己的选择自己用来配置VSCode服务器的时候也要记得选择带宽较大的套餐，否则在网页中使用时极慢的加载速度会让你在浏览器中编写代码的体验水深火热。<br>再购买好自己的服务器，并确保自己能够通过SSH连接到服务器上进行配置之后，我们便可以正式开始在服务器上配置code-server了。<br>首先在自己的服务器上下载coed-server</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/cdr/</span>code-server<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v3.12.0/</span>code-server-<span class="hljs-number">3.12</span>.<span class="hljs-number">0</span>-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p>我在下载的时候，code-server的最新版是3.12.0，在之后下载的朋友可以在<a href="https://github.com/cdr/code-server/releases">这里</a>找到最新版code-server的下载安装连接，注意在下载时选择正确的版本。<br>在下载完成之后，利用</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">sudo</span> tar -zxvf [你的下载下来的<span class="hljs-meta">code</span>-server文件名] -C /<span class="hljs-meta">opt</span>/<br></code></pre></td></tr></table></figure><p>将code-server解压到&#x2F;opt目录下，再使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -s <span class="hljs-regexp">/opt/</span>[code-server文件名]<span class="hljs-regexp">/bin/</span>code-server <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>code-server<br></code></pre></td></tr></table></figure><p>为code-server创建一个软链接，这样就可以直接输入</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">code-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>来启动code-server服务了。     </p><p>安装好code-server之后，首先输入</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">code-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>运行code-server一次，这一次运行会让code-server在现在登录的用户目录~&#x2F;.config&#x2F;code-server下生成一个名叫config.yaml的配置文件，这样我们后续就可以直接编辑这个配置文件来控制code-server启动的相关参数。<br>我们先终止code-server的运行，执行以下命令来编辑code-server的配置文件</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">vim ~<span class="hljs-regexp">/.config/</span>code-server/config.yaml<br></code></pre></td></tr></table></figure><blockquote><p>如果你不喜欢用vim编辑器的话，可以自己采用nano编辑器或者其他的喜欢的编辑器<br>在默认情况下，这个文件应该是这个样子</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">bind-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8080</span><br><span class="hljs-attr">auth:</span> <span class="hljs-string">password</span><br><span class="hljs-attr">password:</span> [<span class="hljs-string">code-server自动生成的密码</span>]<br><span class="hljs-attr">cert:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在第一行，127.0.0.1代表这是本机的IP，如果要在公网上访问的话，需要将这里的IP改为0.0.0.0，后面的端口在默认的情况下是8080，你可以改成自己喜欢的端口号，在第二行的password表示采用密码进行身份验证，我们需要在第三行设置自己熟悉的密码，以方便自己的访问，<del>当然，你把默认生成的密码背下来应该也是可以的</del><br>在进行了这些更改之后，我们再次输入code-server重启服务，如果一次顺利，我们可以看见以下的启动信息</p><img src="/blog/2021/10/30/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%93%E5%BC%80VSCode/1.png" class title="启动画面"><p>我们可以打开浏览器，在地址栏中输入你的服务器公网IP加上你自己设置的端口号，就可以打开自己的VSCode Online界面了。    </p><img src="/blog/2021/10/30/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%93%E5%BC%80VSCode/2.png" class title="界面"><p>输入自己的设置密码，就可以开始把浏览器中的VSCode当作自己本地计算机上的VSCode使用了，不过其中的文件是位于自己的服务器上的。</p><blockquote><p>如果你和我一样使用的阿里云的服务器，可能还需要到服务器的管理界面设置安全组放行相应的端口，具体参考<a href="https://help.aliyun.com/document_detail/59086.html?spm=5176.10173289.help.dexternal.4ff02e77892BZP">这篇文章</a></p></blockquote><h2 id="保持code-server在服务器中的运行"><a href="#保持code-server在服务器中的运行" class="headerlink" title="保持code-server在服务器中的运行"></a>保持code-server在服务器中的运行</h2><p>配置完code-server之后，我们便可以退出SSH登录，愉快的直接利用Online界面来编写代码了。   </p><blockquote><p>由于VSCode自带有终端界面，我们甚至连SSH登录都不需要了<br>但是我们会很快意识到，如果我们退出SSH会话，那么code-server服务也会自动的退出，因为我们如果关闭了SSH， 那么依附其运行的进程也会自动的关闭。我们这里就需要用到一个名叫tmux的软件了。<br>tmux是一个终端复用器，可以让我们在一个终端中，在打开另一个终端，并在其中运行自己想要运行的程序。<br>以下仅是对于tmux的简答介绍，具体可参看<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">这篇教程</a></p></blockquote><p>我们首先安装tmux</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt update<br>sudo apt <span class="hljs-keyword">install</span> tmux<br></code></pre></td></tr></table></figure><blockquote><p>如果你并不和我一样使用Ubuntu，请使用你自己常用的包管理命令安装此软件</p></blockquote><p>我们先输入</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">tmux <span class="hljs-keyword">new</span> -s code-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>创建一个新的会话，可以将“code-server”任何你喜欢的名字，再在这个会话中运行code-server,按下Ctrl+B后再按下D来脱离这个会话，这样，我们就可以放心的退出SSH会话了。<br>以下说说几个tmux常用的命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">tmux ls</span><br></code></pre></td></tr></table></figure><p>列出已创建的会话   </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">tmux attach -t &lt;<span class="hljs-keyword">session</span>-<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><p>再次连接到自己创建的会话   </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">tmux kill-<span class="hljs-keyword">session</span> -t &lt;<span class="hljs-keyword">session</span>-<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><p>删除某个会话</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装vs2019踩的坑</title>
    <link href="/blog/2021/08/14/%E5%AE%89%E8%A3%85vs2019%E8%B8%A9%E7%9A%84%E5%9D%91/"/>
    <url>/blog/2021/08/14/%E5%AE%89%E8%A3%85vs2019%E8%B8%A9%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="安装Visual-Studio-2019中遇到的坑"><a href="#安装Visual-Studio-2019中遇到的坑" class="headerlink" title="安装Visual Studio 2019中遇到的坑"></a>安装Visual Studio 2019中遇到的坑</h1><p>在某个月黑风高的夜晚，我在折腾了很久的Python之后，突然感觉自己应该去学学C和C++，于是乎我便打算折腾一下在vscode上写C和C++。在网上一番搜寻之后，我发现了这篇<a href="https://zhuanlan.zhihu.com/p/87864677">知乎文章</a>和这篇<a href="https://zhuanlan.zhihu.com/p/147366852">知乎文章</a>,然后我就被安装MinGW编译器和配置一大堆的json文件给干碎了。<br><br>于是，我决定转向传说中的宇宙第一IDE——Visual Studio。<br></p><span id="more"></span><p>上网一查，现在最新的vs版本是2019，于是立刻进入<a href="https://visualstudio.microsoft.com/zh-hans/vs/">Visual Studio官网</a>点击下载vs2019<del>enterprise</del>Community版。<br></p><blockquote><p>无他，就是太穷了。<br></p></blockquote><p>在点击下载链接之后，跳转到了感谢下载的界面。<br></p><img src="/blog/2021/08/14/%E5%AE%89%E8%A3%85vs2019%E8%B8%A9%E7%9A%84%E5%9D%91/1.png" class title="感谢下载"><p>上面清楚的写着，下载将很快开始。<br>在经过漫长的等待之后，我下载下来了这个东西</p><blockquote><p>vs_community__355502915.1625217430.exe</p></blockquote><p>于是一波双击，飞快地下载安装选好工作负载，又在一波漫长的下载之后，我兴奋的双击打开了安装好的“vs2019”。</p><p>但是！我却惊讶的发现，我安装的是Visual Studio 2017!<br>我当时就是一脸懵逼，想了想以为是自己在安装工作负载的时候选择错了vs的版本，于是我又打开了visual studio installer，却惊讶的发现，只能安装vs2017的社区版，专业版和企业版。</p><blockquote><p>不可能，微软的软件不会出错，一定是我自己选错了。</p></blockquote><p>我立刻卸载了电脑上的vs2017和Visual Studio Installer,再次前往vs的<a href="https://visualstudio.microsoft.com/zh-hans/vs/">官网</a>,这次我前检查后检查，确定自己下载的是Visual Studio 2019的Community版本，在单击了下载链接之后，我又跳转到了感谢下载的界面。   </p><img src="/blog/2021/08/14/%E5%AE%89%E8%A3%85vs2019%E8%B8%A9%E7%9A%84%E5%9D%91/1.png" class title="感谢下载"><p>但是这次，在令人十分无语的等待之后，<strong>我不得不点了下单击此处以重试</strong>。<br>在一段令人紧张的等待之后，Visual Studio Installer安装好了，我也失望的发现，我安装的仍然是vs2017。</p><blockquote><p>谢谢，电脑已经砸了。</p></blockquote><p>但是，作为一个程序员，我们不能说不！<br>于是，我想到，既然下载开始的如此之慢，要不，<b>挂个梯子</b>试试？<br>说做就做，我又卸载了Visual Studio Installer,在打开VPN之后，我又双打开了<a href="https://visualstudio.microsoft.com/zh-hans/vs/">Visual Studio官网</a>, 怀着紧张而激动的心情，点击了vs2019社区版的下载按钮。仍然一如既往的跳转到了感谢下载的界面，不过这次，下载几乎立刻就开始了！</p><blockquote><p>OHHHHHHHHHHHHHHHHHHH</p></blockquote><p>接着就是双击，下载，安装，我打开Visual Studio Installer，让我安装的果然是vs2019！接着，我泪流满面的选好了工作负载，点击了下载。  </p><h2 id="现在，我们来复盘一下"><a href="#现在，我们来复盘一下" class="headerlink" title="现在，我们来复盘一下"></a>现在，我们来复盘一下</h2><p>我记不清清楚我第一次下载时是否点击了<i>单击此处以重试</i>,但是我的第二次尝试时确定点击了的，在结合开了VPN立刻下载的”解法“，我便将注意力放在了这个按钮上。<br>这是点击重试之后的下载地址：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://download.visualstudio.microsoft.com/download/pr/<span class="hljs-number">343898</span>a<span class="hljs-number">7</span>-<span class="hljs-number">7</span>d<span class="hljs-number">12</span>-<span class="hljs-number">4</span>faa-b<span class="hljs-number">5</span>df-<span class="hljs-number">958</span>b<span class="hljs-number">31</span>e<span class="hljs-number">57</span>b<span class="hljs-number">3</span>e/<span class="hljs-number">0</span>e<span class="hljs-number">17</span>eb<span class="hljs-number">53023</span>c<span class="hljs-number">8</span>a<span class="hljs-number">4</span>d<span class="hljs-number">07</span>e<span class="hljs-number">1</span>dfd<span class="hljs-number">201</span>e<span class="hljs-number">8</span>a<span class="hljs-number">0</span>ebff<span class="hljs-number">2</span>c<span class="hljs-number">56</span>c<span class="hljs-number">74</span>ad<span class="hljs-number">594</span>c<span class="hljs-number">8</span>f<span class="hljs-number">02521</span>fb<span class="hljs-number">5</span>b<span class="hljs-number">27</span>c<span class="hljs-number">7</span>db/vs_Community.exe<br></code></pre></td></tr></table></figure><p>这是不点击重试的下载地址：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://download.visualstudio.microsoft.com/download/pr/<span class="hljs-number">45</span>dfa<span class="hljs-number">82</span>b-c<span class="hljs-number">1</span>f<span class="hljs-number">8</span>-<span class="hljs-number">4</span>c<span class="hljs-number">27</span>-a<span class="hljs-number">5</span>a<span class="hljs-number">0</span>-<span class="hljs-number">1</span>fa<span class="hljs-number">7</span>a<span class="hljs-number">864</span>ae<span class="hljs-number">21</span>/<span class="hljs-number">9</span>dd<span class="hljs-number">77</span>a<span class="hljs-number">8</span>d<span class="hljs-number">1121</span>fd<span class="hljs-number">4382494</span>e<span class="hljs-number">40840</span>faeba<span class="hljs-number">0</span>d<span class="hljs-number">7339</span>a<span class="hljs-number">594</span>a<span class="hljs-number">1603</span>f<span class="hljs-number">0573</span>d<span class="hljs-number">0013</span>b<span class="hljs-number">0</span>f<span class="hljs-number">0</span>fa<span class="hljs-number">5</span>/vs_Community.exe<br></code></pre></td></tr></table></figure><p>下面是我挂着梯子下载下来的安装程序的MD5值：</p><blockquote><p>7382158e92bb9af82a24c5c3eba80c20</p></blockquote><p>下面是不单击重试下载的安装程序的MD5值：</p><blockquote><p>7382158e92bb9af82a24c5c3eba80c20</p></blockquote><p>下面是单击重试下载的安装程序的MD5值：</p><blockquote><p>88f28257ae1e6ce4a7ebd5d6f7f94f0f</p></blockquote><p>至此，真相已经摆在了我的面前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在感谢下载的页面，如果你耐心等待，那么在一段时间后下载的就是vs2019，但是如果你是一个急性子，点击了“单击此处以重试”的按钮。那么你下载的就是vs2017的版本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
